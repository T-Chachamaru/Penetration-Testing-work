# Apache Shiro <= 1.2.4 反序列化漏洞 (CVE-2016-4437)

## 概述 (Overview)

Apache Shiro 是一个流行的、开源的 Java 安全框架，用于简化身份验证、授权、加密和会话管理。此漏洞允许未经身份验证的攻击者通过构造恶意的 `rememberMe` Cookie 值，在目标服务器上执行任意代码。该漏洞存在于 Shiro 1.2.4 及更早版本中。 (通常使用 `vulhub` 等靶场环境进行复现)。

## 识别特征 (Identification)

可以通过检查 HTTP 响应头中是否存在 `Set-Cookie: rememberMe=deleteMe;` 来初步判断目标是否使用了 Shiro 框架。

## 漏洞原理 (Vulnerability Principle)

Shiro 的 `rememberMe` 功能允许用户在关闭浏览器后保持登录状态。其处理流程大致如下：

1.  获取 Cookie 中的 `rememberMe` 值。
2.  对该值进行 Base64 解码。
3.  使用 AES 对解码后的数据进行解密。
4.  对解密后的数据进行 Java 反序列化。

**关键问题在于：** Shiro 在 1.2.4 及之前版本中，用于 AES 加密的密钥是 **硬编码** 在源代码中的 (默认密钥: `kPH+bIxk5D2deZiIxcaaaA==`)。攻击者知道这个默认密钥后，就可以：

1.  使用 `ysoserial` 等工具构造恶意的 Java 序列化对象（payload），例如利用 `CommonsCollections` 等常见 gadget 链执行命令。
2.  使用已知的硬编码密钥对恶意 payload 进行 AES 加密。
3.  将加密后的数据进行 Base64 编码。
4.  将编码后的字符串作为 `rememberMe` Cookie 的值发送给目标服务器。

当服务器接收到这个恶意的 Cookie 时，会执行上述流程，最终反序列化并执行攻击者构造的恶意代码，导致远程代码执行 (RCE)。

## 利用步骤 (Exploitation Steps - Conceptual)

1.  使用 `ysoserial` 或类似工具生成包含命令执行逻辑的 Java 序列化 payload。
2.  使用 Shiro 的默认硬编码 AES 密钥和 AES/CBC/PKCS5Padding 模式加密该 payload。
3.  对加密后的字节进行 Base64 编码。
4.  构造 HTTP 请求，将 Base64 编码后的字符串设置为 `Cookie: rememberMe=<payload>` 的值，并发送给目标服务器。
5.  如果目标存在漏洞且使用了默认密钥，服务器将解密并反序列化 payload，执行其中的恶意代码。