#### 概述：什么是访问控制缺陷？ (Overview: What is a Broken Access Control?)

访问控制缺陷是一种安全漏洞，它发生在应用程序或系统未能正确限制对敏感数据或功能的访问时。这种漏洞允许攻击者未经授权访问本应受限的资源，例如其他用户账户、文件、数据库或管理功能。

##### 什么是访问控制？

访问控制是一种安全机制，用于控制哪些用户或系统被允许访问特定的资源。其主要目标是保护敏感数据，确保只有授权用户才能访问。

##### 四种访问控制机制

1. **自主访问控制 (DAC - Discretionary Access Control)**: 资源的所有者决定谁可以访问资源。
    
    - _类比_: 城堡的国王可以随意将任何门的钥匙分发给他的顾问。
        
2. **强制访问控制 (MAC - Mandatory Access Control)**: 系统根据一组预定义的、不可更改的规则（如安全级别）来决定访问权限。
    
    - _类比_: 拥有铁甲般安全协议的军事堡垒，只有特定安全许可的人员才能进入特定区域。
        
3. **基于角色的访问控制 (RBAC - Role-Based Access Control)**: 用户的访问权限由其在组织中的角色（如管理员、编辑、普通用户）决定。
    
    - _类比_: 现代公司里，经理、销售和普通员工对大楼的访问权限各不相同。
        
4. **基于属性的访问控制 (ABAC - Attribute-Based Access Control)**: 访问权限由一组动态的属性（如用户角色、时间、地理位置、设备类型）共同决定。
    
    - _类比_: 科幻电影中的高级安全系统，它会扫描个体的多种属性来决定是否授权。
        

##### 访问控制失效 (When Access Control is Broken)

当访问控制机制未能正确实施时，就会出现漏洞。

- **水平权限提升 (Horizontal Privilege Escalation)**: 攻击者能够访问与自己权限级别相同的其他用户的资源。
    
    - _示例_: 用户A通过修改 URL 中的用户 ID (`/account?id=123` -> `/account?id=456`) 来访问用户B的账户信息。
        
- **垂直权限提升 (Vertical Privilege Escalation)**: 攻击者能够访问比自己权限级别更高的功能或资源。
    
    - _示例_: 普通用户通过修改 URL (`/dashboard` -> `/admin_panel`) 或操纵隐藏的表单字段来访问管理员面板。
        
- **访问控制检查不足 (Insufficient Access Control Checks)**: 系统在提供数据或功能前，未能一致地验证用户的权限。
    
- **不安全的直接对象引用 (IDOR)**: 应用程序使用可预测的标识符（如自增ID）来直接引用内部对象，攻击者可以通过枚举这些标识符来访问未授权的数据。
    

#### 1. 评估 Web 应用程序 (Assessing a Web Application)

作为渗透测试人员，我们需要使用代理工具（如 **Burp Suite**）来拦截和分析客户端与服务器之间的 HTTP 流量，以寻找访问控制的薄弱环节。

##### 捕获并分析流量

在一个示例应用中，用户登录后，`functions.php` 返回了以下 JSON 响应：

JSON

```
{
  "status": "success",
  "message": "Login successful.",
  "first_name": "John",
  "last_name": "Doe",
  "is_admin": false,
  "redirect_link": "dashboard.php?isadmin=false"
}
```

##### 理解请求与响应

- **服务器信息**: 响应头显示服务器运行在 `Apache/2.4.38 (Debian)` 上，后端语言为 `PHP/8.0.19`。
    
- **安全头**: 缺少常见的安全头（如 `Content-Security-Policy`），表明第一道防线薄弱。
    
- **潜在漏洞**: JSON 响应中包含一个 `redirect_link` 参数 `dashboard.php?isadmin=false`。这种在客户端进行安全决策（是否为管理员）的模式是一个**巨大的危险信号**，极有可能存在访问控制漏洞。
    

#### 2. 利用 Web 应用程序 (Exploiting the Web Application)

1. **拦截响应**: 使用 Burp Suite 拦截上述登录后的 JSON 响应。
    
2. **修改参数**: 在浏览器中，手动访问 `redirect_link` 的 URL，并将其中的参数从 `isadmin=false` 修改为 `isadmin=true`。
    
    - `http://example.com/dashboard.php?isadmin=true`
        
3. **访问管理面板**: 修改参数后，应用程序将我们重定向到了 `admin.php`，这是一个默认对普通用户隐藏的管理面板。
    
4. **垂直权限提升**: 在管理面板中，我们发现了一个可以为用户授予管理员权限的功能。我们勾选自己的账户，点击“保存”，成功将自己的低权限账户提升为了管理员。
    

#### 3. 缓解措施 (Mitigation)

以下是缓解 PHP 应用程序中访问控制缺陷的几种关键策略：

1. 实现基于角色的访问控制 (RBAC)
    
    在服务器端强制执行权限检查，而不是依赖客户端传递的参数。
    
    PHP
    
    ```
    // 安全示例: 在服务器端定义角色和权限
    $roles = [
        'admin' => ['create', 'read', 'update', 'delete'],
        'editor' => ['create', 'read', 'update'],
        'user' => ['read'],
    ];
    
    function hasPermission($userRole, $requiredPermission) {
        global $roles;
        // 检查当前用户的角色是否包含所需权限
        return in_array($requiredPermission, $roles[$userRole]);
    }
    
    if (hasPermission($_SESSION['user_role'], 'delete')) {
        // 允许操作
    } else {
        // 拒绝操作
    }
    ```
    
2. 使用参数化查询 (Parameterized Queries)
    
    防止通过 SQL 注入绕过访问控制。
    
    PHP
    
    ```
    // 漏洞示例: 将用户输入直接拼接到 SQL 查询中
    $query = "SELECT * FROM users WHERE username='$username' AND password='$password'";
    
    // 安全示例: 使用预处理语句 (Prepared Statements)
    $stmt = $pdo->prepare("SELECT * FROM users WHERE username=? AND password=?");
    $stmt->execute([$username, $password]);
    $user = $stmt->fetch();
    ```
    
3. 正确的会话管理 (Proper Session Management)
    
    确保用户会话安全，防止会话劫持。
    
    PHP
    
    ```
    // 安全示例: 设置会话超时
    session_start();
    $_SESSION['user_id'] = $user_id;
    $_SESSION['last_activity'] = time();
    
    // 检查会话是否已过期 (例如 30 分钟)
    if (isset($_SESSION['last_activity']) && (time() - $_SESSION['last_activity'] > 1800)) {
        session_unset();
        session_destroy();
    }
    ```
    
4. 使用安全编码实践 (Secure Coding Practices)
    
    对所有用户输入进行清理和验证，并使用安全的函数。
    
    PHP
    
    ```
    // 安全示例: 清理输入并使用安全的密码哈希函数
    $username = filter_input(INPUT_POST, 'username', FILTER_SANITIZE_STRING);
    
    // 避免使用不安全的哈希函数，如 md5()
    $password = password_hash($password, PASSWORD_DEFAULT);
    ```