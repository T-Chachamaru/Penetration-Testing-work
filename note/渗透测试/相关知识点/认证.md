#### 1. 用户枚举与暴力破解 (User Enumeration & Brute Force)

##### 概述
通过分析应用程序响应、利用常见功能点或公开信息，识别有效用户名和推断密码策略，为后续的暴力破解攻击奠定基础。如同剥洋葱般层层揭示系统认证机制的细节。

##### 方法与技术

1.  **识别有效用户名**
    *   **响应分析**：观察登录或密码重置时应用程序的错误消息差异，如“账户不存在” vs “密码不正确”，以确认有效用户名。
2.  **猜测密码策略**
    *   **错误消息利用**：分析密码验证失败时的错误提示（如需包含特定字符类型），推断密码复杂度要求，优化密码字典。
    *   **源码分析**：若能接触源码（如示例中的PHP正则），可直接了解密码策略。
3.  **常见枚举位置**
    *   **注册页面**：利用“用户名/邮箱已存在”的提示信息确认活跃账户。
    *   **密码重置功能**：分析不同响应（如用户存在与否）来验证用户身份。
    *   **冗长错误信息**：利用区分“用户不存在”和“密码错误”的详细错误，精确识别有效用户名。
    *   **数据泄露信息**：利用已泄露的用户名和密码组合，在目标系统上尝试登录，验证凭据复用情况。
4.  **诱导详细错误**
    *   **目的**：迫使应用程序在错误信息中泄露内部信息（路径、数据库结构、用户信息）。
    *   **手段**：
        *   `无效登录尝试`：通过错误消息差异区分有效/无效用户。
        *   `SQL 注入`：尝试注入特殊字符（如 `'`）触发数据库错误，暴露结构。
        *   `文件包含/路径遍历`：尝试访问受限文件（如 `../../`）触发路径泄露错误。
        *   `表单篡改`：修改隐藏字段或参数值，触发验证错误，暴露后端逻辑或数据结构。
        *   `应用程序模糊测试 (Fuzzing)`：使用工具（如 Burp Intruder）发送大量非预期输入，探测能引发信息性错误的弱点。
5.  **自动化枚举**
    *   使用自动化工具批量测试用户名或邮箱，根据报错信息快速筛选已注册账户。
6.  **密码重置流程漏洞利用**
    *   **常见流程**：基于邮件（发送重置链接/令牌）、基于安全问题、基于短信（发送验证码）。
    *   **常见漏洞**：
        *   `可预测的令牌`：令牌生成模式简单或有序，易被猜测或爆破。
        *   `令牌过期问题`：令牌有效期过长或使用后未立即失效，增加被利用窗口。
        *   `验证不足`：安全问题过于简单或邮箱账户被攻破。
        *   `信息泄露`：错误消息确认账户存在。
        *   `不安全的传输`：通过HTTP传输重置链接或令牌，易被窃听。
    *   **利用示例**：若重置链接中的令牌可预测，可通过自动化工具爆破有效令牌来重置任意用户密码。
7.  **利用HTTP基本认证**
    *   **概述**：简单认证机制（RFC 7617），常见于路由器等设备管理界面。凭证（`username:password`）经Base64编码后在`Authorization: Basic <credentials>`头中传输。
    *   **漏洞**：Base64易解码，主要风险在于弱密码可被暴力破解。
8.  **回溯 URL 和谷歌搜索技巧 (Google Dorking)**
    *   **Wayback URLs**：使用工具导出网站历史存档链接，可能发现旧版本漏洞或信息。
    *   **Google Dorks**：构造特定搜索查询，查找意外暴露的信息。
        *   `site:example.com inurl:admin` (查找管理面板)
        *   `filetype:log "password" site:example.com` (查找含密码的日志)
        *   `intitle:"index of" "backup" site:example.com` (查找备份目录)

#### 2. 会话管理 (Session Management)

##### 概述
管理用户登录状态的过程，涉及会话的创建、跟踪、过期和终止。主要有基于Cookie和基于Token（如JWT）两种方式。

##### Set-Cookie 属性

*   **Secure**: Cookie仅通过HTTPS传输。
*   **HttpOnly**: Cookie值不能被客户端JavaScript读取，防范XSS窃取。
*   **Expires/Max-Age**: Cookie的有效期。
*   **SameSite**: 控制Cookie是否随跨站请求发送，防御CSRF攻击 (Strict, Lax, None)。

##### 基于Token的会话管理

*   **流程**：认证后，服务器返回Token（如JWT）给客户端 -> 客户端（通常通过JS）将Token存储在LocalStorage或SessionStorage -> 后续请求中，客户端JS读取Token并添加到HTTP Header（如`Authorization: Bearer <token>`）发送给服务器。
*   **特点**：不依赖浏览器自动Cookie管理，需要客户端代码主动处理；标准虽有（如JWT），但实现灵活性高。

##### 会话周期安全

1.  **会话创建时的安全**
    *   `弱会话值`：自定义会话ID易被猜测（如仅Base64用户名）。
    *   `可控会话值`：如JWT签名未经验证或密钥泄露，攻击者可伪造有效会话。
    *   `会话固定 (Session Fixation)`：认证成功后未重新生成会话ID，允许攻击者使用预设的会话ID劫持用户登录后的会话。
    *   `不安全的会话传输`：在认证流程中（尤其SSO场景），会话信息通过不安全的重定向暴露给攻击者。
2.  **会话跟踪时的安全**
    *   `授权绕过 (Authorization Bypass)`：
        *   `垂直越权`: 普通用户执行管理员权限操作。
        *   `水平越权`: 用户操作了其无权访问的其他用户的数据。水平越权更难防御，需在代码层面校验数据归属。
    *   `记录不足 (Insufficient Logging)`：缺乏详细的应用层日志（包括成功和失败的操作），难以追踪和分析攻击事件。
3.  **会话过期时的安全**
    *   `会话过期时间过长`：主要漏洞是会话有效期设置太长，增加被劫持后的可用时间。
4.  **会话终止时的安全**
    *   `未在服务器端终止`：用户注销时仅清理客户端状态，服务器端会话依然有效，若会话ID被盗用仍可访问。对Token（尤其JWT）尤为重要，因其自带有效期，需依赖黑名单机制实现强制失效。建议密码重置后终止所有活动会话。

#### 3. JWT安全 (JWT Security)

##### 概述
JSON Web Token (JWT) 是一种常用于API认证的令牌标准。由Header、Payload、Signature三部分组成，通过`.`分隔，各部分使用Base64Url编码。API通常通过特定端点接受凭证，验证成功后返回JWT，客户端在后续请求的`Authorization: Bearer <token>`头中携带此令牌。

##### JWT 结构

*   **Header**: 通常包含令牌类型（`typ`: "JWT"）和签名算法（`alg`）。
*   **Payload**: 包含Claims（声明），即令牌携带的数据，分注册声明、公共声明和私有声明。
*   **Signature**: 用于验证令牌完整性和真实性，使用Header中指定的算法和密钥生成。

##### 签名算法

*   **None**: 不使用签名，令牌无法被验证（用于信任环境或上游已验证场景）。
*   **对称签名 (Symmetric - HS256等)**: 使用共享密钥对Header和Payload进行签名和验证。
*   **非对称签名 (Asymmetric - RS256等)**: 使用私钥签名，公钥验证。

##### 常见漏洞

1.  **敏感信息泄露**
    *   **问题**: 将敏感信息（如密码哈希、明文密码、内部网络信息）直接放入Payload中发送到客户端。
    *   **修复**: 敏感信息应存储在服务端，JWT中只包含用户标识，服务端根据标识查询所需信息。
2.  **未验证签名**
    *   **问题**: 服务器接收JWT后完全不校验签名，导致攻击者可任意修改Payload内容。
    *   **场景**: 可能出现在某些未设防的API端点。
3.  **算法降级为 None**
    *   **问题**: 攻击者修改Header中的`alg`为`none`，并移除Signature部分。如果服务器未禁用`none`算法或校验逻辑不当，会跳过签名验证。
4.  **弱对称密钥**
    *   **问题**: 使用HS256等对称算法时，若密钥过于简单（如"secret", "123456"），可通过离线爆破（如用hashcat, John the Ripper）获得密钥，从而伪造任意JWT。
5.  **签名算法混淆 (Algorithm Confusion)**
    *   **问题**: 服务器预期使用非对称算法（如RS256），但接受了攻击者修改`alg`为对称算法（如HS256）的JWT。若服务器实现不当，可能误将公钥当作HS256的密钥来验证签名。由于公钥通常是公开的，攻击者可用公钥和HS256算法伪造签名。
    *   **利用**: 可使用脚本（如Python的`jwt`库，需修改库代码或使用特定工具/网站）或在线工具（jwt.io）构造。
6.  **令牌有效期过长**
    *   **问题**: `exp`（过期时间）声明设置过长或缺失，导致令牌长期有效。JWT本身难于在有效期前主动撤销（需维护黑名单）。
    *   **修复**: 合理设置`exp`值，根据应用敏感度调整有效期。
7.  **跨服务中继攻击**
    *   **问题**: 在多服务共享同一认证中心的场景下，如果服务B未校验JWT的`aud`（受众）声明，攻击者可能将在服务A获得的具有高权限的JWT（如`"admin": true`）用于访问服务B，实现权限提升。
    *   **修复**: 各服务需严格校验`aud`声明，确保JWT是签发给自己的。

#### 4. OAuth漏洞 (OAuth Vulnerabilities)

##### 概述
OAuth (Open Authorization) 是一个授权框架，允许第三方应用代表用户访问其在某些服务上的资源，而无需获取用户密码。

##### 核心概念

*   **资源所有者 (Resource Owner)**: 用户，数据的拥有者。
*   **客户端 (Client)**: 请求访问资源的应用程序（Web/移动App）。
*   **授权服务器 (Authorization Server)**: 验证用户身份并发放访问令牌的服务器。
*   **资源服务器 (Resource Server)**: 存储受保护资源并响应访问请求的服务器。
*   **授权许可 (Authorization Grant)**: 获取访问令牌的方式（如授权码、密码等）。
*   **访问令牌 (Access Token)**: 客户端用于访问资源的凭证，有有效期和范围限制。
*   **刷新令牌 (Refresh Token)**: 用于获取新的访问令牌，有效期通常较长。
*   **重定向URI (Redirect URI)**: 授权服务器在用户授权后将用户（及授权码/令牌）重定向回的客户端地址，需预先注册。
*   **权限范围 (Scope)**: 限制客户端访问权限的机制（如读取用户信息、修改订单等）。
*   **状态参数 (State Parameter)**: 客户端生成并包含在授权请求中，由授权服务器原样返回，用于防止CSRF攻击并关联请求与响应。
*   **授权端点/令牌端点**: 分别用于用户授权和客户端拿授权许可换取令牌的URL。

##### 授权类型 (Grant Types)

*   **授权码 (Authorization Code)**: 最常用，适用于服务端应用。用户授权后，服务器返回授权码给客户端，客户端再用码和密钥从令牌端点换取令牌。安全性高。
*   **隐式 (Implicit)**: 主要用于无法安全存储密钥的客户端（SPA、移动应用）。用户授权后，令牌直接通过URL片段返回给客户端。安全性较低，OAuth 2.1已不推荐。
*   **资源所有者密码凭证 (Resource Owner Password Credentials)**: 用户直接向客户端提供用户名密码换取令牌。仅用于高度信任的第一方应用。
*   **客户端凭证 (Client Credentials)**: 用于服务器间通信，客户端使用自身凭证获取令牌，无用户参与。

##### 工作流程 (Authorization Code Flow 示例)

1.  **授权请求**: 用户点击“使用XX登录” -> 客户端重定向用户到授权服务器，携带`response_type=code`, `client_id`, `redirect_uri`, `scope`, `state`等参数。
2.  **认证和授权**: 用户在授权服务器登录并同意授权客户端请求的权限范围。
3.  **授权响应**: 授权服务器将用户重定向回客户端预注册的`redirect_uri`，并附带`code`（授权码）和`state`参数。
4.  **令牌请求**: 客户端后台使用收到的`code`、`client_id`、`client_secret`和`redirect_uri`向授权服务器的令牌端点发起POST请求，`grant_type=authorization_code`。
5.  **令牌响应**: 授权服务器验证信息无误后，返回`access_token`、`token_type`（通常是Bearer）、`expires_in`（有效期）和可选的`refresh_token`。
6.  **访问资源**: 客户端使用获取的`access_token`在`Authorization: Bearer <token>`头中向资源服务器请求受保护资源。

##### 识别OAuth服务

*   观察登录页是否有“使用第三方账户登录”（Google, Facebook等）选项。
*   分析网络流量，查找向授权服务器URL的重定向，URL中包含`response_type`, `client_id`, `redirect_uri`等OAuth特征参数。
*   检查HTTP头、响应体、源码，寻找特定OAuth库/框架的标识（如`django-oauth-toolkit`, `passport`等）。
*   分析授权和令牌端点的URL模式。
*   注意错误信息可能泄露使用的技术栈。

##### 常见漏洞

1.  **盗取OAuth令牌 (通过不安全的Redirect URI)**
    *   **漏洞**: `redirect_uri`验证不严格，允许注册通配符、子域名或存在开放重定向漏洞。
    *   **利用**: 攻击者构造授权请求，将`redirect_uri`指向其控制的地址。用户授权后，授权码或令牌被发送到攻击者服务器，攻击者截获后即可冒充用户。
    *   **示例**: 控制`dev.bistro.thm`子域，设置`redirect_uri`到此域下页面，拦截返回的`code`。
2.  **OAuth中的CSRF攻击**
    *   **漏洞**: 缺少`state`参数或`state`参数可预测、可重用。
    *   **利用**: 攻击者诱导已登录目标应用的用户点击恶意链接，该链接启动OAuth流程，但最终使用攻击者预先获取的授权码完成授权，可能导致受害者账户关联到攻击者账户或泄露信息。
    *   **防御**: 必须使用随机、不可预测且与用户会话绑定的`state`参数，并在回调时严格验证。
3.  **隐式授权流程漏洞**
    *   **固有风险**: 访问令牌直接暴露在URL片段中，易被恶意脚本（XSS）窃取；依赖浏览器历史记录安全。
    *   **关联风险**: 若`redirect_uri`验证不严、未使用HTTPS、客户端不安全存储令牌（如LocalStorage），风险加剧。
    *   **现状**: OAuth 2.1 推荐使用带PKCE的授权码流程替代。
4.  **其他漏洞**
    *   `令牌过期不足`: 访问令牌或刷新令牌有效期过长，增加被盗用后的风险。
    *   `重放攻击`: 令牌可被截获并重用（可通过nonce、时间戳等机制缓解）。
    *   `令牌存储不安全`: 客户端将令牌存储在不安全的位置（如LocalStorage），易被XSS窃取。
5.  **OAuth 2.1 的演变**
    *   **主要改进**: 废弃隐式流程，强制要求公共客户端使用PKCE；强制使用`state`参数；强调令牌安全处理（推荐HttpOnly Cookie而非LocalStorage）；细化`redirect_uri`验证等规则，增强安全性与互操作性。

#### 5. 多因素认证 (MFA/2FA)

##### 概述
要求用户提供两种或多种不同类型的身份验证因素，以增强账户安全性。因素类别包括：

*   **你知道的 (Knowledge)**: 密码、PIN码。
*   **你拥有的 (Possession)**: 手机（带认证App）、硬件令牌、智能卡。
*   **你是谁 (Inherence)**: 指纹、面部识别、虹膜扫描。
*   **你在哪 (Location)**: IP地址、地理位置。
*   **你做的 (Behavior)**: 输入模式、鼠标移动（常用于反机器人）。
*   **2FA (Two-Factor Authentication)**: 特指使用两种因素。

##### 常见类型

*   **基于时间的一次性密码 (TOTP)**: 每隔较短时间（如30秒）变化的动态密码（如Google Authenticator）。
*   **推送通知**: 登录请求发送到绑定设备，需用户在设备上确认。
*   **短信验证码 (SMS)**: 发送一次性代码到注册手机号。方便但安全性相对较低（SIM卡交换、短信劫持风险）。
*   **硬件令牌**: 物理设备（如YubiKey）生成OTP或通过NFC/USB进行认证。

##### 条件访问 (Conditional Access)

*   根据上下文动态调整认证要求。
*   **触发条件**: 异常地理位置、非工作时间登录、异常用户行为（访问模式改变）、使用未注册设备等。
*   **响应**: 可能要求额外MFA验证，或直接阻止访问。

##### 常见漏洞

1.  **弱OTP生成算法**: 算法可预测或伪随机数种子不佳，导致OTP易被猜测。
2.  **泄露2FA令牌**:
    *   **途径**: 应用程序在HTTP响应中（尤其XHR请求的响应）意外返回OTP值；调试信息遗留在生产环境；日志记录不当。
3.  **爆破OTP**:
    *   **条件**: 缺乏速率限制或账户锁定机制。
    *   **利用**: 攻击者可无限制或大量尝试猜测OTP。
4.  **中间人钓鱼 (MITM Phishing)**
    *   **工具**: 如Evilginx。
    *   **原理**: 设置钓鱼网站作为用户与真实网站之间的代理，截获用户名、密码以及用户输入的OTP或会话Cookie，从而绕过MFA。
5.  **2FA逻辑绕过**:
    *   **问题**: 应用程序在验证流程、会话管理或访问控制上存在缺陷。
    *   **表现**: 攻击者可能在未完成MFA验证的情况下直接访问受保护资源（如通过修改URL、操纵请求流程）。
6.  **利用自动注销/会话失效机制**:
    *   **场景**: 某些应用在MFA失败次数过多时会强制用户重新登录（第一步认证）。
    *   **利用**: 如果重新登录后可以继续尝试MFA，且没有整体尝试次数限制或锁定，攻击者可通过自动化脚本（如示例Python脚本）反复执行“登录 -> 尝试OTP -> 被踢回登录页 -> 重新登录 -> 尝试下一个OTP”的循环，进行暴力破解。