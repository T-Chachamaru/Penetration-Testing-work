#### 概述：什么是杀毒软件？ (Overview: What is Antivirus Software?)

病毒防护软件（Antivirus Software, AV）是一种部署在终端设备上的附加安全层，其核心目标是检测、阻止和移除恶意文件（如病毒、蠕虫、特洛伊木马、勒索软件、间谍软件等）在目标操作系统中的执行和传播。它通常作为一个基于主机的应用程序，在后台实时运行，以监控和检查系统当前活动以及新下载或创建的文件。

##### 1. AV 软件的关注点 (What AV Software Looks For)

传统杀毒软件主要通过预定义的恶意模式或**签名 (Signatures)** 来查找恶意软件。恶意软件 (Malware, Malicious Software) 指的是任何以对目标计算机系统造成损害为主要目的的软件，其具体目的可能包括但不限于：

- 获取目标机器的完全访问权限。
- 窃取敏感信息，如用户密码、个人数据、财务信息。
- 加密用户文件以进行勒索 (勒索软件)。
- 损坏系统文件或用户数据。
- 注入其他类型的恶意软件或不需要的广告软件 (Adware)。
- 将被攻陷的机器用作执行进一步攻击的平台，例如作为僵尸网络 (Botnet) 的一部分发起 DDoS 攻击或发送垃圾邮件。

##### 2. 杀毒软件与其他安全产品的区别与联系 (Antivirus Software vs. Other Security Products)

除了传统的病毒防护软件，现代端点安全还依赖于其他解决方案：

- **终端检测与响应 (Endpoint Detection and Response, EDR)**: EDR 是一种更侧重于行为分析的安全解决方案，它提供实时监控和威胁响应能力。与 AV 主要执行扫描、检测和删除已知恶意文件不同，EDR 会监控端点上的多种活动，包括文件操作、内存使用、网络连接、Windows 注册表修改、进程创建和行为等，旨在检测更复杂和未知的威胁，特别是那些可能绕过传统 AV 签名的攻击。

许多现代的“杀毒”产品或终端安全套件，正在将传统的基于签名的 AV 功能与更高级的类似 EDR 的功能（如行为分析、启发式扫描、反漏洞利用等）集成到一个统一的产品中，以提供对数字威胁的全面防护。

##### 3. 杀毒软件的演进：过去与现在 (The Evolution of Antivirus Software)

- **早期 (Past)**:
    
    - McAfee Associates, Inc. 于 1987 年推出了最早的商业杀毒软件之一，名为 "VirusScan"，最初目标是清除感染其创始人约翰·麦克菲计算机的 "Brain" 病毒。
    - 早期的杀毒软件通常被称为“扫描器 (Scanners)”，是基于命令行的工具，主要通过在文件中搜索已知的恶意模式来进行检测。
- **现代 (Present)**:
    
    - 现代杀毒软件通常提供图形用户界面 (GUI)，使用户可以方便地执行扫描、配置设置和查看报告。
    - 恶意软件的范围已极大扩展，针对 Windows、Linux、macOS、Android、iOS 等多种操作系统和平台。因此，现代 AV 也支持跨平台防护。
    - 现代 AV 变得更加智能和复杂，集成了多种功能，如实时防病毒、反漏洞利用、防火墙、加密工具、反垃圾邮件、家长控制等，形成综合性的安全套件。

---

#### 杀毒引擎：核心检测能力 (Antivirus Engine: Core Detection Capabilities)

杀毒引擎是 AV 软件的核心，负责实际查找、分析和移除恶意代码与文件。一个优秀的杀毒引擎应具备高效、准确、快速分析恶意文件的能力，并能处理和支持多种文件类型，包括能够自我提取并检查所有压缩内容的归档文件。

尽管不同 AV 产品的实现方式各异，但其引擎通常包含以下核心功能组件：

##### 1. 扫描器 (Scanner)

扫描器是 AV 产品的基本功能，可以在实时模式下（监控文件创建、访问、修改）或按需模式下（用户手动发起扫描）运行。

- **接口**: 可通过 GUI 或命令行界面使用。
- **目标**: 用户可以扫描特定文件、目录、整个驱动器，甚至系统内存和注册表。
- **支持**: 必须支持最常见的恶意文件类型，以有效检测和清除威胁。某些 AV 还支持特定类型的扫描，如漏洞扫描、电子邮件附件扫描等。

##### 2. 检测技术 (Detection Techniques)

AV 引擎使用多种技术来搜索和识别恶意文件：

- **基于签名的检测 (Signature-based Detection)**: 传统的 AV 技术，通过在文件中查找与已知恶意软件匹配的预定义模式（字节序列、哈希值等）或签名。
- **启发式检测 (Heuristic-based Detection)**: 一种更高级的技术，使用各种经验法则和行为模式来分析可疑文件，试图识别未知或变种恶意软件。
- **动态检测 (Dynamic Detection / Sandboxing)**: 通过在隔离的、受控的环境中（沙盒）执行可疑文件，监控其行为（如系统调用、API 调用、文件系统和注册表修改等）来判断其是否恶意。

这些技术将在后续章节详细讨论。

##### 3. 压缩与归档文件处理 (Compression and Archiving)

恶意代码常通过隐藏在压缩文件 (如 ZIP, RAR, 7z, TGZ, XAR 等) 中来规避安全检测。因此，AV 软件必须具备以下能力：

- **支持多种格式**: 能够识别和处理各种常见的压缩和归档文件类型。
- **解压与扫描**: 在用户打开或执行归档中的文件之前，能够自动解压缩并扫描其中的所有文件。

##### 4. PE 解析与脱壳工具 (PE Parsing and Unpacking Tools)

- **Windows PE 头解析器**: AV 软件需要能够解析 Windows 可移植可执行文件 (PE) 的头部信息。PE 文件格式 (用于 .exe, .dll 等) 包含丰富的元数据和结构信息 (如导入表、导出表、节区信息、资源等)，分析这些信息有助于区分恶意软件和合法软件。
- **脱壳 (Unpacking)**: 恶意软件开发者经常使用加壳器 (Packers) 如 UPX, Armadillo, ASPack 等，来压缩、加密或混淆恶意代码，使其难以进行静态分析，并改变其文件结构和签名。AV 软件必须能够识别并脱掉（解包）这些已知的加壳器保护，将压缩或混淆的可执行文件还原到更接近原始代码的状态，以便进行有效的静态分析和签名匹配。

##### 5. 模拟器/沙盒 (Emulator/Sandbox)

模拟器或沙盒是 AV 软件中用于对可疑文件进行深入动态分析的功能。

- **工作方式**: 当 AV 引擎遇到一个可疑文件（如 .exe, .dll, PDF, Office 文档等）且静态分析不足以确定其性质时，可能会将其提交到模拟器/沙盒中执行。这是一个虚拟化的、受控的环境，与真实用户系统隔离。
- **监控行为**: 在模拟执行过程中，AV 会监控文件的一系列行为，例如：
    - 调用的 Windows API。
    - 内存分配和访问模式。
    - 文件系统和注册表的修改。
    - 记录的系统事件。
    - 创建或交互的其他进程。
    - 发起的网络连接和请求。
- **判定**: 当模拟器收集到足够的证据表明该文件行为恶意时，会停止执行并将其标记为恶意软件。

##### 6. 其他常见功能 (Other Common Features)

- **自我保护驱动程序 (Self-Protection Driver)**: 防止恶意软件篡改或禁用 AV 软件自身的进程、文件、注册表项等。
- **防火墙与网络检查 (Firewall and Network Inspection)**: 监控网络流量，阻止恶意连接和网络攻击。
- **命令行与图形界面工具 (CLI and GUI Tools)**: 提供不同的用户交互方式。
- **守护进程或服务 (Daemon or Service)**: 后台运行的核心服务进程。
- **管理控制台 (Management Console)**: 尤其是企业版 AV，用于集中管理和配置。

---

#### 杀毒软件检测方法详解 (Antivirus Detection Methods Explained)

AV 软件的检测方法通常可以分为三大主要类别：

1. **静态检测 (Static Detection)**
2. **动态检测 (Dynamic Detection)**
3. **启发式与行为检测 (Heuristic and Behavioral Detection)**

##### 1. 静态检测 (Static Detection)

静态检测是最基础也是历史最悠久的 AV 检测技术。它**不执行**被分析的文件，而是基于文件本身的静态特征和预定义的恶意软件签名数据库进行匹配。

- **核心原理**: 使用模式匹配技术，在待检测文件中查找与已知恶意软件样本中提取的特征相符的内容。
    
- **常见签名类型**:
    
    - **唯一字符串 (Unique Strings)**: 例如恶意软件中硬编码的特定命令、URL、文件名、互斥体名称等。
    - **CRC32 校验和 (Checksums)**: 对文件或文件的一部分计算校验和，但容易因微小变动而失效。
    - **字节序列/十六进制值 (Byte Sequences/Hex Values)**: 提取恶意代码中独特的、不易改变的机器码片段。
    - **密码学哈希 (Cryptographic Hashes)**: 如 MD5, SHA1, SHA256。对整个文件计算哈希值。只要文件有任何一点改动，哈希值就会完全不同。
- **工作流程**: AV 软件将待检测文件的特征（或整个文件）与庞大的签名数据库进行比较。如果找到匹配的签名，则该文件被判定为恶意。
    
- **有效性**: 对已知的、未加修改的静态恶意软件非常有效。
    
- **局限性**:
    
    - **仅针对已知威胁**: 必须先捕获和分析恶意软件样本，并为其生成签名更新到数据库中，才能检测到。对于全新的、未知的恶意软件 (0-day) 无能为力。
    - **数据库依赖**: 签名数据库需要频繁更新，以应对新出现的威胁。
    - **易被绕过**: 攻击者可以通过轻微修改恶意代码（如重编译、加壳、混淆、加密）来改变其静态特征或哈希值，从而轻松绕过基于签名的检测。

**ClamAV 静态检测演示**:

ClamAV 是一款开源的 AV 软件，常用于演示基于签名的检测。假设 ClamAV 已安装 (例如在 `c:\Program Files\ClamAV\clamscan.exe`)，并且在桌面上有以下恶意软件样本：

1. `EICAR.COM`: 标准的 AV 测试文件，包含一段特定的 ASCII 字符串，用于验证 AV 是否正常工作，本身并非恶意。
2. `backdoor1.exe`: 一个使用已知技巧（如创建进程执行 Metasploit Shellcode）建立反向连接的 C# 后门。
3. `backdoor2.exe`: 一个使用了进程注入和加密（如 XOR 加密 Metasploit Shellcode）来建立反向连接的 C# 后门。
4. `AV-Check.exe`: 一个用于枚举目标机器上已安装 AV 软件的 C# 程序。
5. `notes.txt`: 一个包含命令行的文本文件。

- **扫描 Malware 样本文件夹**:
    
    DOS
    
    ```
    c:\>"c:\Program Files\ClamAV\clamscan.exe" c:\Users\thm\Desktop\Samples
    ```
    
    可能的输出（示意）：
    
    ```
    Loading:     22s, ETA:   0s [========================>]    8.61M/8.61M sigs
    Compiling:    4s, ETA:   0s [========================>]       41/41 tasks
    
    C:\Users\thm\Desktop\Samples\AV-Check.exe: OK
    C:\Users\thm\Desktop\Samples\backdoor1.exe: Win.Malware.Swrort-9872015-0 FOUND
    C:\Users\thm\Desktop\Samples\backdoor2.exe: OK
    C:\Users\thm\Desktop\Samples\eicar.com: Win.Test.EICAR_HDB-1 FOUND
    C:\Users\thm\Desktop\Samples\notes.txt: OK
    ```
    
    分析：
    
    - `eicar.com` 和 `backdoor1.exe` 被正确标记为恶意。
    - `AV-Check.exe` 和 `notes.txt` 被识别为正常。
    - `backdoor2.exe` **未被检测到 (OK)**，尽管它实际上是恶意的。
- **检测原理分析**:
    
    - **`backdoor1.exe`**: ClamAV 可能通过其解包模块和对 Metasploit Shellcode 常用字节序列的预定义签名检测到了它。如果运行 `clamscan.exe --debug <file>`，可以看到它加载模块、分割文件并查找恶意字节序列的过程。
    - **`eicar.com`**: ClamAV 通常使用基于 MD5 的签名来检测 EICAR 测试文件。 在调试模式下扫描 `eicar.com` 可能看到类似输出：
        
        ```
        LibClamAV debug: FP SIGNATURE: 44d88612fea8a8f36de82e1278abb02f:68:Win.Test.EICAR_HDB-1  # Name: eicar.com, Type: CL_TYPE_TEXT
        ```
        
        使用 `sigtool.exe` (ClamAV 工具套件的一部分) 计算 `eicar.com` 的 MD5 值：
        
        DOS
        
        ```
        c:\>"c:\Program Files\ClamAV\sigtool.exe" --md5 c:\Users\thm\Desktop\Samples\eicar.com
        44d88612fea8a8f36de82e1278abb02f:68:eicar.com
        ```
        
        可以看到 MD5 哈希 `44d88612fea8a8f36de82e1278abb02f` 匹配，确认了是基于 MD5 的签名。
    - **`backdoor2.exe` 为何未被检测**: `backdoor2.exe` 使用了加密技术 (如 XOR) 对其 Shellcode 进行了加密。这导致其字节序列与 ClamAV 数据库中已知的 Metasploit Shellcode 签名不匹配，因此成功逃避了基于签名的检测。
- 创建自定义签名数据库 (ClamAV):
    
    如果 ClamAV 官方数据库未能检测到某个恶意软件 (如 backdoor2.exe)，我们可以为其创建自定义签名并添加到本地数据库中。
    
    1. **为文件生成 MD5 签名**:
        
        DOS
        
        ```
        C:\Users\thm\Desktop\Samples>"c:\Program Files\ClamAV\sigtool.exe" --md5 backdoor2.exe
        75047189991b1d119fdb477fef333ceb:6144:backdoor2.exe
        ```
        
        输出格式为 `哈希:文件大小:文件名`。
    2. **将签名添加到 `.hdb` 数据库文件**: 将 `sigtool` 的输出重定向到一个新文件 (例如 `thm.hdb`)。
        
        DOS
        
        ```
        C:\Users\thm\Desktop\Samples>"c:\Program Files\ClamAV\sigtool.exe" --md5 backdoor2.exe > thm.hdb
        ```
        
    3. **使用新数据库重新扫描**: 使用 `-d` 参数指定自定义数据库文件。
        
        DOS
        
        ```
        C:\Users\thm\Desktop\Samples>"c:\Program Files\ClamAV\clamscan.exe" -d thm.hdb backdoor2.exe
        Loading:     0s, ETA:   0s [========================>]        1/1 sigs
        Compiling:   0s, ETA:   0s [========================>]       10/10 tasks
        
        C:\Users\thm\Desktop\Samples\backdoor2.exe: backdoor2.exe.UNOFFICIAL FOUND
        ```
        
        结果显示，使用自定义数据库后，ClamAV 成功将 `backdoor2.exe` 标记为恶意 (通常会带有 UNOFFICIAL 标记)。
- 静态检测的 Yara 规则:
    
    Yara 是一个广泛用于恶意软件研究和检测的工具，它允许研究人员基于文本或二进制模式创建描述恶意软件家族的规则。ClamAV 也可以加载和使用 Yara 规则。
    
    1. **分析目标文件以提取特征**: 以 `AV-Check.exe` 为例。使用 `strings` 工具分析，可能会发现其 PDB (Program Database) 路径字符串是比较独特的：
        
        DOS
        
        ```
        C:\Users\thm\Desktop\Samples>strings AV-Check.exe | findstr pdb
        C:\Users\thm\source\repos\AV-Check\AV-Check\obj\Debug\AV-Check.pdb
        ```
        
    2. **创建初始 Yara 规则 (`thm-demo-1.yara`)**:
        
        代码段
        
        ```
        rule thm_demo_rule {
            meta:
                author = "THM: Intro-to-AV-Room"
                description = "Look at how the Yara rule works with ClamAV"
            strings:
                $a = "C:\\Users\\thm\\source\\repos\\AV-Check\\AV-Check\\obj\\Debug\\AV-Check.pdb" // 注意路径中的双反斜杠转义
            condition:
                $a // 如果找到字符串 $a，则匹配
        }
        ```
        
        当 ClamAV 使用此规则扫描时，它可能会正确标记 `AV-Check.exe`，但也可能因为 `notes.txt` 文件中也包含了这个 PDB 路径字符串而产生**误报 (False Positive)**。
    3. **改进 Yara 规则以减少误报 (`thm-demo-2.yara`)**: 为了提高准确性，可以添加文件类型检查。例如，可执行文件 (.exe) 通常以 "MZ" (ASCII) 或 `4D 5A` (十六进制) 作为文件开头的魔数 (Magic Number)。
        
        代码段
        
        ```
        rule thm_demo_rule {
            meta:
                author = "THM: Intro-to-AV-Room"
                description = "Look at how the Yara rule works with ClamAV"
            strings:
                $a = "C:\\Users\\thm\\source\\repos\\AV-Check\\AV-Check\\obj\\Debug\\AV-Check.pdb"
                $b = "MZ" // "MZ" 魔数
            condition:
                $b at 0 and $a // 字符串 $b 必须在文件偏移量 0 处找到，并且字符串 $a 也必须存在
        }
        ```
        
        使用这个改进后的规则重新扫描，可以更准确地仅标记包含 PDB 路径的 `.exe` 文件，从而减少对 `notes.txt` 的误报。
        
        DOS
        
        ```
        C:\Users\thm>"c:\Program Files\ClamAV\clamscan.exe" -d Desktop\Files\thm-demo-2.yara Desktop\Samples
        ```
        
        预期输出：
        
        ```
        C:\Users\thm\Desktop\Samples\AV-Check.exe: YARA.thm_demo_rule.UNOFFICIAL FOUND
        C:\Users\thm\Desktop\Samples\backdoor1.exe: OK
        C:\Users\thm\Desktop\Samples\backdoor2.exe: OK
        C:\Users\thm\Desktop\Samples\eicar.com: OK
        C:\Users\thm\Desktop\Samples\notes.txt: OK
        ```
        

##### 2. 动态检测 (Dynamic Detection)

动态检测方法比静态检测更为高级和复杂，它侧重于在**运行时**检查文件的行为，而不是仅仅分析其静态内容。

- **通过监控 Windows API 调用**:
    
    - 检测引擎会检查 Windows 应用程序的系统调用。
    - 可以使用 Windows 钩子 (Hooks) 或其他内核级监控技术来拦截和分析进程对关键 Windows API 的调用，例如文件操作、注册表访问、进程创建、网络通信等相关的 API。
    - 如果一系列 API 调用模式与已知的恶意行为相符，则可能将该进程标记为恶意。
- **沙盒 (Sandboxing)**:
    
    - 沙盒是一个隔离的、虚拟化的执行环境，用于安全地运行可疑文件。
    - 其主要目标是在不影响主机系统的情况下，观察和分析恶意软件在受控环境中的完整行为。
    - 一旦确认文件是恶意的，AV 会根据其行为特征创建新的签名或行为规则，并可能将这些更新推送到云端数据库，供其他用户使用。
- **缺点与绕过**:
    
    - **资源消耗**: 在虚拟环境中执行和监控恶意软件需要时间和系统资源。
    - **可被规避**: 恶意软件开发者会采用各种技术来检测自身是否运行在沙盒或虚拟环境中 (VM-aware malware)，例如检查特定的硬件ID、驱动程序、注册表项、进程列表，或通过计时差异来判断。如果检测到是沙盒环境，恶意软件可能改变其行为、延迟执行恶意载荷，或者干脆不执行任何恶意操作，以逃避动态分析。

##### 3. 启发式与行为检测 (Heuristic and Behavioral Detection)

启发式和行为检测是现代 AV 产品对抗未知威胁和复杂恶意软件的关键技术。

- **静态启发式分析 (Static Heuristic Analysis)**:
    
    - 尝试（如果可能）反编译可疑软件，并分析其源代码结构、函数调用、使用的字符串、代码复杂度等。
    - 将这些特征与已知病毒或恶意软件家族的通用代码模式或“可疑”属性（例如，包含大量无用指令、试图隐藏自身、直接进行硬件访问等）进行比较。
    - 如果一个文件的特征与恶意启发式规则的匹配度达到或超过某个阈值，则可能被标记为可疑或恶意。
- **动态启发式/行为分析 (Dynamic Heuristic/Behavioral Analysis)**:
    
    - 基于预定义的恶意行为规则集。安全研究人员在隔离环境中分析可疑软件的行为，并根据其发现总结出通用的恶意行为模式。
    - AV 软件在运行时监控进程的行为，如果其行为序列匹配了这些预定义的恶意行为规则，则将其标记为恶意。
    - **行为规则示例**:
        - 一个进程尝试读取或修改 `LSASS.exe` 进程的内存（该进程存储用户 NTLM 哈希、Kerberos 票据等敏感凭据）。
        - 一个非浏览器进程打开一个监听端口并等待来自命令与控制 (C2) 服务器的指令。
        - 一个进程在没有用户交互的情况下修改系统启动项。
        - 一个进程大量加密用户文件。

---

#### AV 厂商与病毒检测环境 (AV Vendors and Virus Detection Environments)

##### 1. AV 厂商 (AV Vendors)

市场上有众多 AV 软件供应商，主要面向家庭用户和企业用户提供安全产品。现代 AV 产品已从单纯的病毒扫描发展为集成了多种安全特性的综合套件，例如防火墙、加密工具、反垃圾邮件、EDR 功能、漏洞扫描、VPN 服务等。

选择“最好”的 AV 软件非常困难，因为它很大程度上取决于用户的具体需求、偏好、预算和使用经验。企业级 AV 通常更注重集中管理、策略部署和高级威胁防护能力。

##### 2. 病毒检测环境 (Virus Detection Environments)

在线病毒检测平台是检查可疑或恶意文件的重要工具。它们允许用户上传文件，并使用多个不同的 AV 引擎对其进行扫描。

- **VirusTotal (VT)**:
    
    - 一个非常知名的基于网络的扫描平台，使用超过 70 个不同的 AV 引擎以及其他分析工具来检查上传的文件和 URL。
    - 提供多维度分析结果，包括：
        - 各 AV 引擎的检测结果 (签名匹配)。
        - 文件基本信息和哈希值。
        - 黑名单 URL 或服务检查。
        - 静态和动态行为分析 (在沙盒中运行)。
        - API 调用序列、模块加载等。
    - **重要提示 (共享策略)**: VirusTotal 会将所有扫描的文件和结果**共享给 AV 供应商和安全社区**。这有助于改进 AV 产品和更新恶意软件数据库。然而，对于红队成员或渗透测试人员来说，在 VT 上扫描自己开发的 Payload 或 C2 工具会**暴露这些工具**，可能导致其在实际演练中被快速检测。
- VirusTotal 替代方案 (注重隐私):
    
    考虑到 VT 的共享策略，测试恶意软件时（尤其是在红队活动中），可以使用一些不共享扫描样本和结果的平台。但这些平台通常也有其限制，例如每日扫描次数有限，或需要付费订阅才能进行无限测试。
    
    - `Antiscan.me`
    - `Virus Scan Jotti's malware scan`

---

#### 指纹识别杀毒软件 (Fingerprinting Antivirus Software)

在获得目标机器的初始访问权限后，红队成员或渗透测试人员通常需要识别目标系统上部署了哪些主机安全产品，尤其是 AV 软件。这个过程称为**防病毒指纹识别 (Antivirus Fingerprinting)**。了解已安装的 AV 产品有助于：

- 选择合适的绕过技术。
- 在本地搭建相同的测试环境，以验证绕过技术的有效性。

##### 1. 常见 AV 软件及其关联进程/服务 (Common AVs and Associated Processes/Services)

|   |   |   |
|---|---|---|
|**AV 厂商 (Vendor)**|**服务名/驱动名 (Service/Driver Name) 例**|**进程名 (Process Name) 例**|
|Microsoft Defender|WinDefend|MSMpEng.exe|
|Trend Micro|TMBMSRV|TMBMSRV.exe|
|Avira|AntivirService, Avira.ServiceHost|avguard.exe, Avira.ServiceHost.exe|
|Bitdefender|VSSERV|bdagent.exe, vsserv.exe|
|Kaspersky|A1VP&lt;Version #> (e.g., AVP21.3)|avp.exe, ksde.exe|
|AVG|AVG Antivirus|AVGSvc.exe|
|Norton|Norton Security|NortonSecurity.exe|
|McAfee|McAPExe, Mfemms|McAPExe.exe, mfemms.exe|
|Panda|PavPrSvr|PavPrSvr.exe|
|Avast|Avast Antivirus|afwServ.exe, AvastSvc.2exe|

_(3注意: 服务名和进程名可能随 AV 版本更新而变化)_

##### 2. 使用公共工具进行指纹识别 (Using Public Tools for Fingerprinting)

- **SharpEDRChecker**:
    - 一个用 C# 编写的开源工具，用于检测目标机器上可能存在的 EDR 和 AV 产品。
    - 通过执行多种检查来实现指纹识别，包括：
        - 检查正在运行的进程列表。
        - 检查文件元数据。
        - 检查加载的 DLL 文件。
        - 查询特定的注册表键。
        - 枚举系统服务。
        - 检查特定目录和文件是否存在。
    - 编译后运行，可能会被某些 AV 自身标记为恶意，因为它执行了许多敏感的检查和 API 调用。

##### 3. 编写自定义 C# 程序进行指纹识别 (Writing Custom C# Programs for Fingerprinting)

可以编写自定义脚本或程序来枚举 AV 产品。以下是一个简单的 C# 示例 (`AV-Check.exe`)，它通过检查运行进程列表来识别已知的 AV 进程：

C#

```
using System;
using System.Management; // 需要添加 System.Management.dll 引用

internal class Program
{
    static void Main(string[] args)
    {
        var status = false;
        Console.WriteLine("[+] Antivirus check is running .. ");
        // 预定义的知名 AV 进程名列表
        string[] AV_Check_Processes = {
            "MsMpEng.exe", "AdAwareService.exe", "afwServ.exe", "avguard.exe", "AVGSvc.exe",
            "bdagent.exe", "BullGuardCore.exe", "ekrn.exe", "fshoster32.exe", "GDScan.exe",
            "avp.exe", "K7CrvSvc.exe", "McAPExe.exe", "NortonSecurity.exe", "PavFnSvr.exe",
            "SavService.exe", "EnterpriseService.exe", "WRSA.exe", "ZAPrivacyService.exe"
            // 可以根据需要添加更多
        };

        try
        {
            // 使用 WMI 查询当前运行的所有进程
            ManagementObjectSearcher searcher = new ManagementObjectSearcher("select Name from win32_process");
            ManagementObjectCollection processList = searcher.Get();

            foreach (ManagementObject process in processList)
            {
                string processName = process["Name"]?.ToString();
                if (!string.IsNullOrEmpty(processName))
                {
                    // 与预定义列表比较
                    if (Array.Exists(AV_Check_Processes, avProc => avProc.Equals(processName, StringComparison.OrdinalIgnoreCase)))
                    {
                        Console.WriteLine("--AV Found: {0}", processName);
                        status = true;
                        // 可以选择找到一个就退出，或者继续查找所有已知的
                        // break;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("[!] Error during AV check: " + ex.Message);
        }


        if (!status)
        {
            Console.WriteLine("--AV software is not found (based on running processes)!");
        }
    }
}
```

- **代码解释**:
    
    - 代码中预定义了一个包含常见 AV 进程名的字符串数组 `AV_Check_Processes`。
    - 使用 WMI (Windows Management Instrumentation) 查询 `select Name from win32_process` 来获取当前所有正在运行的进程列表。
    - 遍历运行进程列表，将其名称与预定义数组中的名称进行比较（忽略大小写）。
    - 如果找到匹配项，则认为检测到了相应的 AV 软件。
- **VirusTotal 测试与误报**:
    
    - 将此类自定义指纹识别工具（如 `AV-Check.exe`）上传到 VirusTotal，有时即使它本身不包含任何恶意代码，也可能被少数 AV 引擎标记为恶意。
        
    - **原因**:
        
        - 这些工具执行的操作（如查询所有进程、访问 WMI）与某些恶意软件或侦察工具的行为相似。
        - 一些 AV 供应商可能使用了实现不够完善的机器学习分类器或过于宽泛的基于规则的检测方法，导致对这类合法但“可疑”行为的工具产生误报。
        - VirusTotal 的行为分析部分可能会显示程序调用的 Windows API、注册表操作、WMIC 查询等，某些组合可能会触发其沙箱环境中的 Sigma 规则或其他行为检测规则。
    - 编译为不同体系结构 (x86 vs. x64) 可能会得到略微不同的 VirusTotal 检测结果，这可能与特定 AV 引擎对不同体系结构二进制文件的分析能力或签名库有关。