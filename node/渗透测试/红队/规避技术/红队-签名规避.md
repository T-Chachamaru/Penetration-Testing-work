
#### 目录
- [签名识别基础](#签名识别基础-fundamentals-of-signature-identification)
- [静态代码签名规避技术](#静态代码签名规避技术-bypassing-static-code-based-signatures)
- [基于静态属性的签名规避](#基于静态属性的签名规避-bypassing-static-attribute-based-signatures)
- [行为特征规避与动态API加载](#行为特征规避与动态api加载-bypassing-behavioral-signatures--dynamic-api-loading)

#### 签名识别基础 (Fundamentals of Signature Identification)

在尝试破解或绕过 AV/EDR 的静态签名之前，首要任务是理解并准确识别这些签名的具体内容和位置。如《反病毒入门》中所述，签名是反病毒引擎用来追踪和识别可疑或恶意程序的关键特征。

##### 1. 手动迭代定位签名 (Manual Iterative Signature Location)

识别二进制文件中签名的具体字节位置通常采用一种迭代的二进制分割和测试过程：

1. **初步分割**: 使用原生命令行工具如 `head` (Linux/macOS)、`dd` (Linux/macOS) 或 `split` (Linux/macOS)，或者 PowerShell 中的类似功能，将编译好的二进制文件（例如，由 msfvenom 生成的载荷）大致分成两半。
    
    - **示例 (使用 `head` 查找 msfvenom 二进制文件中首次出现的签名)**: 假设原始文件为 `payload.bin`，大小为 `N` 字节。
        
        Bash
        
        ```
        # 创建上半部分
        head -c (N/2) payload.bin > upper_half.bin
        # 创建下半部分 (需要工具如 `tail` 或更精确的 `dd`)
        # dd if=payload.bin of=lower_half.bin bs=1 skip=(N/2)
        ```
        
2. **测试与迭代**:
    
    - 将分割后的文件（例如，先测试 `upper_half.bin`）从开发环境移动到装有目标 AV 引擎的测试机器上。
    - **如果出现警报**: 说明签名存在于当前测试的这一半文件中。继续对这一半文件进行再分割（例如，将 `upper_half.bin` 再分成两半），然后测试新的上半部分。
    - **如果未出现警报**: 说明签名存在于原始文件的另一半（未测试的那一半）。转向那一半文件，对其进行分割，然后测试其上半部分。
    - 持续这种模式，不断缩小包含签名的字节范围。这个过程通常在文件大小缩小到千字节 (KB) 级别时，手动分割变得不那么精确。
3. 十六进制编辑器精确定位:
    
    当你无法通过文件分割进一步精确缩小范围时（例如，文件片段已经很小，或者签名跨越了分割点），可以使用十六进制编辑器（如 HxD, 010 Editor）打开包含签名的最小文件片段。通过观察和分析（有时需要结合反汇编），可以更精确地定位签名的起始和结束字节。签名的可读性（即是否能直接看出其代表的恶意代码特征）取决于原始工具的生成方式和编译方法。
    

##### 2. 自动化签名识别工具 (Automated Signature Identification Tools)

手动分割和测试过程非常耗时。为了提高效率，可以使用脚本或专用工具来自动化此过程。

- 脚本辅助分割 (Find-AVSignature.ps1):
    
    PowerShell 脚本 Find-AVSignature.ps1 可以通过用户给定的间隔 (Interval) 自动分割提供的字节范围 (StartByte, EndByte)。
    
    PowerShell
    
    ```
    PS C:\> . .\Find-AVSignature.ps1
    PS C:\> Find-AVSignature
    
    cmdlet Find-AVSignature at command pipeline position 1
    Supply values for the following parameters:
    StartByte: 0
    EndByte: max # 或者具体的文件大小
    Interval: 1000 # 例如，每1000字节分割一次
    
    Do you want to continue?
    This script will result in X binaries being written to "C:\Users\TryHackMe"!
    [Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"): y
    ```
    
    **局限性**:
    
    - 脚本虽然减轻了手动工作，但仍需要用户交互来判断哪个片段触发了 AV。
    - 需要根据文件大小和预期的签名长度合理设置分割间隔。
    - 通常只观察文件被写入磁盘时的二进制内容，可能无法完全利用 AV 引擎的全部扫描功能（例如，内存解包、行为模拟等）。
- 利用 AV 引擎进行扫描的工具:
    
    为了更准确地识别签名，可以使用那些能够直接调用本地 AV 引擎（如 Windows Defender 或 AMSI）进行扫描的工具。常见的有 DefenderCheck, ThreatCheck, 和 AMSITrigger。
    
    - ThreatCheck:
        
        ThreatCheck 是 DefenderCheck 的一个分支，被广泛认为是这三者中功能较全面和可靠的工具之一。它利用本地 AV 引擎（默认为 Windows Defender，也可指定 AMSI）对二进制文件进行分块扫描，并报告其认为包含恶意字节的偏移量。
        
        基本语法:
        
        DOS
        
        ```
        C:\>ThreatCheck.exe --help
          -e, --engine    (Default: Defender) Scanning engine. Options: Defender, AMSI
          -f, --file      Analyze a file on disk
          -u, --url       Analyze a file from a URL
          --help          Display this help screen.
          --version       Display version information.
        ```
        
        **使用示例 (扫描 Grunt C2 的二进制文件)**:
        
        DOS
        
        ```
        C:\>ThreatCheck.exe -f Downloads\Grunt.bin -e AMSI
            [+] Target file size: 31744 bytes
            [+] Analyzing...
            [!] Identified end of bad bytes at offset 0x6D7A
            00000000   65 00 22 00 3A 00 22 00  7B 00 32 00 7D 00 22 00   e·"·:·"·{·2·}·"·
            00000010   2C 00 22 00 74 00 6F 00  6B 00 65 00 6E 00 22 00   ,·"·t·o·k·e·n·"·
            ... (hex dump of the identified signature start) ...
        ```
        
        ThreatCheck 直接指出了恶意字节序列结束的偏移量。使用方法：首先识别出首次发现的“坏字节”区域，然后针对性地修改或混淆这部分代码，再次运行 ThreatCheck，如此迭代，直到不再识别出签名。
        
    - AMSITrigger:
        
        AMSI (反恶意软件扫描接口) 在运行时环境中运作，使得某些内存中的脚本或代码块的签名更难通过简单的静态文件扫描来识别和定位。ThreatCheck 对某些文件类型（如 PowerShell 脚本）的支持可能不如 AMSITrigger。AMSITrigger 专门利用 AMSI 引擎的扫描功能来分析（尤其是 PowerShell）脚本，并报告触发警报的具体代码部分。
        
        语法使用:
        
        DOS
        
        ```
        C:\>amsitrigger.exe --help
            -i, --inputfile=VALUE      Powershell filename
            -u, --url=VALUE            URL eg. <https://10.1.1.1/Invoke-NinjaCopy.ps1>
            -f, --format=VALUE         Output Format:
                                         1 - Only show Triggers
                                         2 - Show Triggers with Line numbers
                                         3 - Show Triggers inline with code
                                         4 - Show AMSI calls (xmas tree mode)
            -d, --debug                Show Debug Info
            -m, --maxsiglength=VALUE   Maximum signature Length to cater for, default=2048
            -c, --chunksize=VALUE      Chunk size to send to AMSIScanBuffer, default=4096
            -h, -?, --help             Show Help
        ```
        
        **使用示例**:
        
        PowerShell
        
        ```
        PS C:\> .\amsitrigger.exe -i bypass.ps1 -f 3 # -f 3 表示内联显示触发部分的代码
        # 输出示例 (可能高亮或标记出 bypass.ps1 脚本中触发 AMSI 警报的具体行或代码块)
        # [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
        ```
        
        AMSITrigger 可以帮助精确定位 PowerShell 脚本中导致 AMSI 检测的“元凶”。
        

---

#### 静态代码签名规避技术 (Bypassing Static Code-based Signatures)

一旦通过上述方法识别出二进制文件或脚本中触发 AV/EDR 警报的静态特征（签名），就需要决定如何处理它。根据签名的强度和类型，可能通过《代码混淆技术》笔记中介绍的简单混淆方法就能破解，也可能需要更具针对性的调查和补救措施。

《分层混淆：用于分层安全软件混淆技术的分类法》这篇研究论文为我们提供了许多可靠的混淆思路，特别是在其“方法层 (Method Layer)”和“类层 (Class Layer)”中。

##### 1. 混淆方法 (方法层 - Obfuscation Methods - Method Layer)

|   |   |
|---|---|
|**混淆方法 (Obfuscation Method)**|**目的 (Purpose)**|
|**方法代理 (Method Proxy)**|创建一个代理方法或替换对象来间接调用原始方法，或者用一个外观相似但实现不同的方法替换原始方法。|
|**方法分散/聚合 (Method Scattering/Aggregation)**|将多个相关的小方法合并成一个大方法，或者将一个复杂的大方法拆分成多个独立的小方法，并通过调用链连接起来。|
|**方法克隆 (Method Clone)**|创建一个或多个与原始方法功能相同但实现细节（如代码顺序、使用的临时变量等）略有不同的副本，并在运行时随机调用这些副本之一。|

##### 2. 混淆类 (类层 - Obfuscation Classes - Class Layer)

|                                           |                                                                                                                         |
| ----------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| **混淆方法 (Obfuscation Method)**             | **目的 (Purpose)**                                                                                                        |
| **类层次结构扁平化 (Class Hierarchy Flattening)** | 通过使用接口 (Interfaces) 或组合 (Composition) 来替代复杂的类继承关系，为原有类创建功能等效但结构不同的代理。                                                   |
| **类拆分/合并 (Class Splitting/Coalescing)**   | 将一个类中的局部变量或指令组（方法的一部分）转移到另一个新创建的类或现有类中，或者将多个小类的功能合并到一个大类中。                                                              |
| **移除修饰符 (Dropping Modifiers)**            | 移除类成员（字段、方法）的访问修饰符（如 `public`, `private`, `protected`），并将所有成员尽可能地设为 `public`（这更多是为了方便某些类型的反射操作或动态修改，但也可能改变某些静态分析工具的判断）。 |

通用化概念:

尽管上述表格中的术语可能特定于某些编程范式，但许多概念可以归纳为适用于任何对象或数据结构的通用方法：

- **拆分/合并**: “技术分类拆分/合并” 和 “方法分散/聚合” 都可以概括为对任何给定的面向对象编程 (OOP) 功能或数据结构进行拆分或合并操作，以改变其静态表现形式。
- **移除/掩盖可识别信息**: “删除修饰符” 或 “方法克隆”（如果克隆版本使用了不同的命名或内部实现）等技术，可以归纳为移除或掩盖程序中可被静态分析工具或人工分析师识别的特征信息。

##### 3. 拆分和合并对象以破坏签名 (Splitting and Merging Objects to Break Signatures)

这种方法论与《代码混淆技术》笔记中讨论的**对象连接 (Object Concatenation)** 非常相似。其核心思想是创建一个或多个新的对象或函数，它们在功能上等同于原始的、被标记的部分，但由于其结构或内容的改变，不再匹配已知的恶意签名。

案例研究：Covenant C2 的 GetMessageFormat 字符串混淆

Covenant C2 框架中某个版本的 MessageFormat 字符串曾被 AV 检测。

- **原始被检测字符串 (示意)**:
    
    C#
    
    ```
    // string MessageFormat = @"{""GUID"":""{0}"",""Type"":{1},""Meta"":""{2}"",""IV"":""{3}"",""EncryptedMessage"":""{4}"",""HMAC"":""{5}""}}";
    ```
    
- **混淆方法 (使用 `StringBuilder` 进行动态拼接)**: 通过创建一个新的静态属性或方法，在运行时使用 `StringBuilder` 来动态构建这个格式化字符串，而不是将其作为静态常量直接存储在代码中。
    
    C#
    
    ```
    public static string GetMessageFormat // 将字符串获取封装为静态属性的 get 访问器
    {
        get // 当访问此属性时，执行以下代码返回值
        {
            var sb = new StringBuilder(@"{""GUID"":""{0}"","); // 初始化 StringBuilder，并添加第一部分
            sb.Append(@"""Type"":{1},");                      // 追加后续部分
            sb.Append(@"""Meta"":""{2}"",");
            sb.Append(@"""IV"":""{3}"",");
            sb.Append(@"""EncryptedMessage"":""{4}"",");
            sb.Append(@"""HMAC"":""{5}""}}");
            return sb.ToString(); // 返回拼接完成的完整字符串
        }
    }
    
    // 使用时：
    // string MessageFormat = SomeClass.GetMessageFormat; // 调用属性获取字符串
    ```
    
    这种方式将一个完整的、可能被签名的静态字符串分解为多个在编译时独立存在（或在运行时才组合）的片段，从而可能规避基于该完整字符串的静态签名。

##### 4. 移除和混淆可识别信息 (Removing and Obfuscating Identifiable Information)

在 Mimikatz 等工具的某些版本中，特定的字符串（例如 `wdigest.dll`，与早期 Windows 版本中内存凭据窃取相关）可能会触发 AV 警报。一个简单的解决方法是用任何随机的、无意义的标识符替换这个字符串，并在代码中所有使用到该字符串的地方都进行同样的替换。

这种技术可以被归类为《分层混淆分类法》中的**方法代理 (Method Proxy)** 或 **无意义的标识符 (Meaningless Identifiers)** 的一种应用（如果替换的是变量名或函数名，则更接近后者；如果替换的是传递给 API 的参数字符串，则更像是改变了调用的“形态”）。

---

#### 基于静态属性的签名规避 (Bypassing Static Attribute-based Signatures)

除了代码内容（字符串、字节序列）本身，AV/EDR 或分析师还可能考虑二进制文件的其他静态属性来支持其判断。这些签名可以附加到多个文件属性上，并常用于 YARA 或 Sigma 等规则集中。

常见属性包括：文件哈希值、文件熵、作者信息、文件名、编译时间戳、PE头中的特定字段值，或其他可从文件元数据中提取的可识别信息。这些属性可以单独使用，也可以组合使用形成更复杂的检测规则。

某些属性（如文件名）很容易被操纵，而另一些属性（如文件哈希、签名PE文件中的数字签名）则更难在不破坏文件功能或有效性的情况下进行修改，尤其是在处理预编译的、闭源的应用程序时。

##### 1. 文件哈希值 (File Hashes)

文件哈希值（也称校验和，如 MD5, SHA1, SHA256）用于唯一标记或识别文件。它们常被 AV 用于快速判断文件是否为已知恶意软件。任何对文件内容的微小修改都会导致其哈希值发生巨大变化。

- **有源码的情况**: 如果可以访问应用程序的源代码，只需对代码进行任意无害的修改（例如，添加注释、改变变量名、调整代码顺序等）并重新编译，就可以生成一个具有全新哈希值的新文件。
- **处理预编译或签名的应用程序：位翻转 (Bit-Flipping)**: 对于无法重新编译的二进制文件，可以尝试使用**位翻转**技术。这是一种通过系统性地翻转（XOR 操作）文件中的每一个比特（或字节），并测试每个变体是否仍然保持功能，来生成大量文件变体的方法。
    - **原理**: 对文件中的一个字节 `B` 与一个掩码（例如 `0xDE` 或 `0x01` 逐位翻转）进行异或操作 `B' = B ^ MASK`。这个操作会改变该字节，从而改变整个文件的哈希值和基于内容的签名。关键在于找到一个或多个“可行的”翻转位，使得文件功能不受影响（或仅轻微影响），但哈希已改变。
    - **Python 位翻转示例 (逐字节与 0xDE 异或)**:
        
        Python
        
        ```
        import sys
        
        try:
            with open(sys.argv[1], "rb") as f:
                orig_bytes = bytearray(f.read()) # Read as bytearray for mutability
        except Exception as e:
            print(f"Error reading file: {e}")
            sys.exit(1)
        
        i = 0
        while i < len(orig_bytes):
            current_bytes = bytearray(orig_bytes) # Create a mutable copy
            current_bytes[i] = orig_bytes[i] ^ 0xde # Flip the i-th byte
        
            path = "%d.exe" % i # Output filename
            try:
                with open(path, "wb") as f_out:
                    f_out.write(current_bytes)
            except Exception as e:
                print(f"Error writing file {path}: {e}")
        
            i += 1
        
        print("done")
        ```
        
    - **验证功能性**: 生成大量位翻转变体后，必须测试它们是否仍然能够正常工作，并且（如果原始文件是签名的）其数字签名是否仍然有效或以可接受的方式损坏。例如，如果对 `msbuild.exe` 这样的已签名微软二进制文件进行位翻转，需要使用 `signtool.exe` (Windows SDK 工具) 来验证其签名状态。一个简单的批处理脚本可以遍历生成的变体并进行验证：
        
        代码段
        
        ```
        FOR /L %%A IN (1,1,10000) DO (
            echo Verifying flipped\%%A.exe
            signtool verify /v /pa flipped\%%A.exe || echo Verification failed for %%A.exe
            REM /pa enforces default Authenticode policy
        )
        ```
        
        目标是找到一个哈希已改变、但功能和（如果重要的话）签名归属仍然完整的变体。

##### 2. 文件熵 (File Entropy)

根据 IBM 的定义，熵 (Entropy) 被定义为“文件中数据的随机性，用于判断文件是否包含隐藏数据或可疑脚本。”EDR 和其他扫描器通常利用熵值来识别潜在的可疑文件（例如，高度压缩或加密的数据通常具有高熵），或作为计算整体恶意评分的一个因素。

- **熵对混淆脚本的影响**: 当对可识别信息（如变量名、函数名）进行随机化混淆时（例如，将 `myVariable` 替换为 `q234uf9zX`），可能会显著增加脚本的熵值。
- **降低熵的策略**: 为了避免因熵值过高而触发警报，可以将随机生成的标识符替换为从字典中随机选择的、看起来正常的英文单词。例如，将随机变量名 `q234uf` 更改为 `nature` 或 `window`。
- **使用 CyberChef 观察熵变**: 可以使用 CyberChef 工具的 "Entropy" 操作来计算和比较不同文本的香农熵：
    - 标准英文段落的香农熵：约 4.5 - 4.7。
    - 包含大量随机字符标识符的小脚本的香农熵：可能显著高于此值，例如原文提到的 5.34。
    - 根据不同的 EDR 产品，一个“可疑”的熵值阈值可能大约在 6.8 或更高。
- **注意事项**: 熵值通常不会单独作为判定恶意的唯一标准，而是作为支持其他可疑指标的一个因素。例如，正常的系统工具 `pskill.exe` 和某个漏洞利用程序（如针对 Hivenightmare 漏洞的利用）可能具有相似的熵值。
- **实际案例**: 白皮书《对高级持续性威胁攻击向量的端点检测与响应系统的实证评估》中提到，SentinelOne EDR 曾由于一个 DLL 文件中使用了 AES 加密导致其熵值过高，而将其检测为可疑。

---

#### 行为特征规避与动态API加载 (Bypassing Behavioral Signatures & Dynamic API Loading)

即使通过混淆函数和文件属性成功破解了基于静态签名的检测，现代 AV/EDR 引擎仍然可能通过观察二进制文件在运行时的**行为和功能**来识别恶意活动。这对攻击者来说提出了许多无法通过简单静态混淆解决的问题。

如《反病毒入门》所述，现代 AV 引擎检测行为的两种常见方法是：**观察导入表 (IAT) 以了解程序意图**，以及**挂钩 (Hook) 已知的可疑或恶意 API 调用**。

##### 1. API 调用、IAT 与 ASLR

- Windows API 调用和操作系统中的其他原生函数，其执行通常需要：
    
    1. 一个指向函数实际内存地址的**指针**。
    2. 一个定义了函数参数和返回类型的**结构体**（即函数原型或签名）。
- 这些函数的结构体（原型）信息通常在开发时通过包含头文件（如 `windows.h`）获得，而函数的实际代码则位于导入库（如 `kernel32.dll`, `ntdll.dll`）中。
    
- 由于 **ASLR (地址空间布局随机化)** 的存在，这些库及其中的函数在每次加载到内存时，其基址和函数地址都可能是动态变化的，因此不能硬编码函数地址。
    
- **Windows 加载器与 IAT**:
    
    - Windows 加载器 (Loader) 在程序启动时负责将所有必需的模块（DLL）映射到进程的地址空间，并解析导入函数的地址。
    - **IAT (导入地址表 Import Address Table)** 是 PE 文件中（通常在 `.idata` 或 `.rdata` 节）的一个关键数据结构。它在加载时由 Windows 加载器填充，存储了所有从外部 DLL 导入的函数的实际内存地址（通常是指向称为 "thunk" 的小段跳转代码的指针，这些 thunk 再跳转到实际的 API 函数）。当程序调用一个导入函数时，它实际上是通过 IAT 中的条目来间接调用。
    - IAT 的内容可以被静态分析工具（如 PE-bear, CFF Explorer）轻易查看，从而暴露程序可能使用的敏感 API，为分析师提供大量关于二进制文件功能的线索。

##### 2. 动态加载 API 以规避 IAT 检测 (Dynamic API Loading to Bypass IAT Detection)

如果希望避免某些敏感 API 函数的名称直接出现在程序的导入地址表 (IAT) 中，从而减少静态分析时的可疑特征，可以使用**动态加载 (Dynamic Loading)** 技术。

这种技术的核心思想是：不通过链接器在编译时静态链接到目标 API，而是在运行时使用 `LoadLibrary` (或 `LoadLibraryEx`) API 手动加载包含目标函数的 DLL，然后使用 `GetProcAddress` API 根据函数名字符串动态获取该函数在内存中的实际地址。

**使用 C 语言动态加载 API 的步骤**:

1. 定义函数指针类型 (Call Structure):
    
    首先，需要为要动态加载的 API 函数定义一个与之签名匹配的函数指针类型。这个结构（参数类型、返回类型、调用约定）可以在微软官方文档 (MSDN/Microsoft Learn) 中找到。
    
    例如，为 GetComputerNameA 定义函数指针类型：
    
    C
    
    ```
    // 1. 定义函数指针类型 (调用结构)
    typedef BOOL (WINAPI* MyGetComputerNameAFunc)(
        LPSTR   lpBuffer,
        LPDWORD nSize
    );
    // 使用 "MyGetComputerNameAFunc" 或其他自定义名称，避免与 windows.h 中的原始声明冲突 (如果包含了windows.h)
    ```
    
2. 加载包含目标 API 的模块 (LoadLibraryA / LoadLibraryW):
    
    在运行时调用 LoadLibraryA (或 LoadLibraryW，推荐) 来加载包含目标 API 的 DLL (例如，kernel32.dll 或 ntdll.dll)。这将返回该 DLL 在当前进程地址空间中的模块句柄 (HMODULE)。
    
    C
    
    ```
    // 2. 获取包含目标 API 地址的模块的句柄
    HMODULE hKernel32 = LoadLibraryA("kernel32.dll"); // 加载 kernel32.dll
    // if (hKernel32 == NULL) { /* 错误处理: DLL 加载失败 */ }
    ```
    
3. 获取目标 API 的进程地址 (GetProcAddress):
    
    使用上一步获得的模块句柄和目标 API 的名称字符串，调用 GetProcAddress 来获取该 API 在内存中的实际地址。将返回的地址强制转换为先前定义的函数指针类型。
    
    C
    
    ```
    // 3. 获取目标 API 的进程地址
    MyGetComputerNameAFunc pfnGetComputerNameA = (MyGetComputerNameAFunc)GetProcAddress(
        hKernel32,
        "GetComputerNameA" // 要获取地址的函数名字符串
    );
    // if (pfnGetComputerNameA == NULL) { /* 错误处理: 函数地址获取失败 */ FreeLibrary(hKernel32); }
    ```
    
4. 通过函数指针调用 API (Using the New Call):
    
    现在可以通过获取到的函数指针来调用目标 API，就像调用普通函数一样。
    
    C
    
    ```
    // char computerName[MAX_COMPUTERNAME_LENGTH + 1];
    // DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
    // if (pfnGetComputerNameA(computerName, &size)) {
    //     printf("Computer Name: %s\n", computerName);
    // }
    // FreeLibrary(hKernel32); // 使用完毕后，如果不再需要该 DLL，可以卸载
    ```
    

**注意事项与进一步的规避**:

- LoadLibrary 和 GetProcAddress 仍然在 IAT 中:
    
    尽管目标 API (如 GetComputerNameA) 的名称本身没有出现在 IAT 中，但用于动态加载它们的 LoadLibraryA (或 W) 和 GetProcAddress 这两个函数本身通常仍然会通过 IAT 导入。它们的出现也可能引起分析师的注意，因为它们是动态解析和执行代码的常用手段。
    
    - **潜在解决方案**:
        - **位置无关代码 (Position Independent Code, PIC)**: 在 Shellcode 或注入的模块中，可以通过更底层的技术（例如，从 PEB 中遍历已加载模块链表，手动解析导出表）来定位 `LoadLibrary` 和 `GetProcAddress` 的地址，而无需将它们列在自身的 IAT 中。
        - 将这两个函数名本身也进行混淆（如字符串加密），在运行时解密后再传递给（可能也是动态解析的）`GetProcAddress`。
- API 挂钩 (API Hooking):
    
    现代 EDR 和 AV 解决方案通常会挂钩 (Hook) 许多敏感的 API 调用（无论它们是如何被解析的），以监控其参数和调用上下文。即使通过动态加载隐藏了 IAT 中的条目，对这些被挂钩 API 的实际调用仍然可能被检测到。
    
    - **潜在解决方案**:
        - **API 解钩 (API Unhooking)**: 尝试检测并移除 EDR/AV 设置的钩子，恢复 API 的原始入口点。这是一项复杂且高风险的技术。
        - **直接系统调用 (Direct Syscalls)**: 绕过用户模式 API 层，直接构造和发起内核级系统调用。这也非常复杂，并且系统调用号可能因 Windows 版本而异。
        - **使用未被广泛监控的替代 API**: 寻找功能类似但较少被监控的 API 组合来实现相同目的。